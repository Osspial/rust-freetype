/* automatically generated by rust-bindgen */

pub type FT_Int16 = i16;
pub type FT_UInt16 = u16;
pub type FT_Int32 = i32;
pub type FT_UInt32 = u32;
pub type FT_Int64 = i64;
pub type FT_UInt64 = u64;
pub use FT_Error;

pub const FT_RENDER_POOL_SIZE: ::std::os::raw::c_uint = 16384;
pub const FT_MAX_MODULES: ::std::os::raw::c_uint = 32;
pub const FT_CHAR_BIT: ::std::os::raw::c_uint = 8;
pub const FT_USHORT_MAX: ::std::os::raw::c_uint = 65535;
pub const FT_INT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const FT_INT_MIN: ::std::os::raw::c_int = -2147483648;
pub const FT_UINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const FT_LONG_MIN: ::std::os::raw::c_int = -2147483648;
pub const FT_LONG_MAX: ::std::os::raw::c_uint = 2147483647;
pub const FT_ULONG_MAX: ::std::os::raw::c_uint = 4294967295;
pub const FT_SIZEOF_INT: ::std::os::raw::c_uint = 4;
pub const FT_SIZEOF_LONG: ::std::os::raw::c_uint = 4;
pub const FT_OUTLINE_CONTOURS_MAX: ::std::os::raw::c_uint = 32767;
pub const FT_OUTLINE_POINTS_MAX: ::std::os::raw::c_uint = 32767;
pub const FT_OUTLINE_NONE: ::std::os::raw::c_uint = 0;
pub const FT_OUTLINE_OWNER: ::std::os::raw::c_uint = 1;
pub const FT_OUTLINE_EVEN_ODD_FILL: ::std::os::raw::c_uint = 2;
pub const FT_OUTLINE_REVERSE_FILL: ::std::os::raw::c_uint = 4;
pub const FT_OUTLINE_IGNORE_DROPOUTS: ::std::os::raw::c_uint = 8;
pub const FT_OUTLINE_SMART_DROPOUTS: ::std::os::raw::c_uint = 16;
pub const FT_OUTLINE_INCLUDE_STUBS: ::std::os::raw::c_uint = 32;
pub const FT_OUTLINE_HIGH_PRECISION: ::std::os::raw::c_uint = 256;
pub const FT_OUTLINE_SINGLE_PASS: ::std::os::raw::c_uint = 512;
pub const FT_CURVE_TAG_ON: ::std::os::raw::c_uint = 1;
pub const FT_CURVE_TAG_CONIC: ::std::os::raw::c_uint = 0;
pub const FT_CURVE_TAG_CUBIC: ::std::os::raw::c_uint = 2;
pub const FT_CURVE_TAG_HAS_SCANMODE: ::std::os::raw::c_uint = 4;
pub const FT_CURVE_TAG_TOUCH_X: ::std::os::raw::c_uint = 8;
pub const FT_CURVE_TAG_TOUCH_Y: ::std::os::raw::c_uint = 16;
pub const FT_CURVE_TAG_TOUCH_BOTH: ::std::os::raw::c_uint = 24;
pub const FT_Curve_Tag_On: ::std::os::raw::c_uint = 1;
pub const FT_Curve_Tag_Conic: ::std::os::raw::c_uint = 0;
pub const FT_Curve_Tag_Cubic: ::std::os::raw::c_uint = 2;
pub const FT_Curve_Tag_Touch_X: ::std::os::raw::c_uint = 8;
pub const FT_Curve_Tag_Touch_Y: ::std::os::raw::c_uint = 16;
pub const FT_RASTER_FLAG_DEFAULT: ::std::os::raw::c_uint = 0;
pub const FT_RASTER_FLAG_AA: ::std::os::raw::c_uint = 1;
pub const FT_RASTER_FLAG_DIRECT: ::std::os::raw::c_uint = 2;
pub const FT_RASTER_FLAG_CLIP: ::std::os::raw::c_uint = 4;
pub const FT_ERR_BASE: ::std::os::raw::c_uint = 0;
pub const FT_FACE_FLAG_SCALABLE: ::std::os::raw::c_uint = 1;
pub const FT_FACE_FLAG_FIXED_SIZES: ::std::os::raw::c_uint = 2;
pub const FT_FACE_FLAG_FIXED_WIDTH: ::std::os::raw::c_uint = 4;
pub const FT_FACE_FLAG_SFNT: ::std::os::raw::c_uint = 8;
pub const FT_FACE_FLAG_HORIZONTAL: ::std::os::raw::c_uint = 16;
pub const FT_FACE_FLAG_VERTICAL: ::std::os::raw::c_uint = 32;
pub const FT_FACE_FLAG_KERNING: ::std::os::raw::c_uint = 64;
pub const FT_FACE_FLAG_FAST_GLYPHS: ::std::os::raw::c_uint = 128;
pub const FT_FACE_FLAG_MULTIPLE_MASTERS: ::std::os::raw::c_uint = 256;
pub const FT_FACE_FLAG_GLYPH_NAMES: ::std::os::raw::c_uint = 512;
pub const FT_FACE_FLAG_EXTERNAL_STREAM: ::std::os::raw::c_uint = 1024;
pub const FT_FACE_FLAG_HINTER: ::std::os::raw::c_uint = 2048;
pub const FT_FACE_FLAG_CID_KEYED: ::std::os::raw::c_uint = 4096;
pub const FT_FACE_FLAG_TRICKY: ::std::os::raw::c_uint = 8192;
pub const FT_FACE_FLAG_COLOR: ::std::os::raw::c_uint = 16384;
pub const FT_FACE_FLAG_VARIATION: ::std::os::raw::c_uint = 32768;
pub const FT_STYLE_FLAG_ITALIC: ::std::os::raw::c_uint = 1;
pub const FT_STYLE_FLAG_BOLD: ::std::os::raw::c_uint = 2;
pub const FT_OPEN_MEMORY: ::std::os::raw::c_uint = 1;
pub const FT_OPEN_STREAM: ::std::os::raw::c_uint = 2;
pub const FT_OPEN_PATHNAME: ::std::os::raw::c_uint = 4;
pub const FT_OPEN_DRIVER: ::std::os::raw::c_uint = 8;
pub const FT_OPEN_PARAMS: ::std::os::raw::c_uint = 16;
pub const FT_LOAD_DEFAULT: ::std::os::raw::c_uint = 0;
pub const FT_LOAD_NO_SCALE: ::std::os::raw::c_uint = 1;
pub const FT_LOAD_NO_HINTING: ::std::os::raw::c_uint = 2;
pub const FT_LOAD_RENDER: ::std::os::raw::c_uint = 4;
pub const FT_LOAD_NO_BITMAP: ::std::os::raw::c_uint = 8;
pub const FT_LOAD_VERTICAL_LAYOUT: ::std::os::raw::c_uint = 16;
pub const FT_LOAD_FORCE_AUTOHINT: ::std::os::raw::c_uint = 32;
pub const FT_LOAD_CROP_BITMAP: ::std::os::raw::c_uint = 64;
pub const FT_LOAD_PEDANTIC: ::std::os::raw::c_uint = 128;
pub const FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH: ::std::os::raw::c_uint = 512;
pub const FT_LOAD_NO_RECURSE: ::std::os::raw::c_uint = 1024;
pub const FT_LOAD_IGNORE_TRANSFORM: ::std::os::raw::c_uint = 2048;
pub const FT_LOAD_MONOCHROME: ::std::os::raw::c_uint = 4096;
pub const FT_LOAD_LINEAR_DESIGN: ::std::os::raw::c_uint = 8192;
pub const FT_LOAD_NO_AUTOHINT: ::std::os::raw::c_uint = 32768;
pub const FT_LOAD_COLOR: ::std::os::raw::c_uint = 1048576;
pub const FT_LOAD_COMPUTE_METRICS: ::std::os::raw::c_uint = 2097152;
pub const FT_LOAD_BITMAP_METRICS_ONLY: ::std::os::raw::c_uint = 4194304;
pub const FT_LOAD_ADVANCE_ONLY: ::std::os::raw::c_uint = 256;
pub const FT_LOAD_SBITS_ONLY: ::std::os::raw::c_uint = 16384;
pub const FT_SUBGLYPH_FLAG_ARGS_ARE_WORDS: ::std::os::raw::c_uint = 1;
pub const FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES: ::std::os::raw::c_uint = 2;
pub const FT_SUBGLYPH_FLAG_ROUND_XY_TO_GRID: ::std::os::raw::c_uint = 4;
pub const FT_SUBGLYPH_FLAG_SCALE: ::std::os::raw::c_uint = 8;
pub const FT_SUBGLYPH_FLAG_XY_SCALE: ::std::os::raw::c_uint = 64;
pub const FT_SUBGLYPH_FLAG_2X2: ::std::os::raw::c_uint = 128;
pub const FT_SUBGLYPH_FLAG_USE_MY_METRICS: ::std::os::raw::c_uint = 512;
pub const FT_FSTYPE_INSTALLABLE_EMBEDDING: ::std::os::raw::c_uint = 0;
pub const FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING: ::std::os::raw::c_uint = 2;
pub const FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING: ::std::os::raw::c_uint = 4;
pub const FT_FSTYPE_EDITABLE_EMBEDDING: ::std::os::raw::c_uint = 8;
pub const FT_FSTYPE_NO_SUBSETTING: ::std::os::raw::c_uint = 256;
pub const FT_FSTYPE_BITMAP_EMBEDDING_ONLY: ::std::os::raw::c_uint = 512;
pub const FT_ADVANCE_FLAG_FAST_ONLY: ::std::os::raw::c_uint = 536870912;
pub const FT_AUTOHINTER_SCRIPT_NONE: ::std::os::raw::c_uint = 0;
pub const FT_AUTOHINTER_SCRIPT_LATIN: ::std::os::raw::c_uint = 1;
pub const FT_AUTOHINTER_SCRIPT_CJK: ::std::os::raw::c_uint = 2;
pub const FT_AUTOHINTER_SCRIPT_INDIC: ::std::os::raw::c_uint = 3;
pub const FT_CFF_HINTING_FREETYPE: ::std::os::raw::c_uint = 0;
pub const FT_CFF_HINTING_ADOBE: ::std::os::raw::c_uint = 1;
pub const FT_GASP_NO_TABLE: ::std::os::raw::c_int = -1;
pub const FT_GASP_DO_GRIDFIT: ::std::os::raw::c_uint = 1;
pub const FT_GASP_DO_GRAY: ::std::os::raw::c_uint = 2;
pub const FT_GASP_SYMMETRIC_GRIDFIT: ::std::os::raw::c_uint = 4;
pub const FT_GASP_SYMMETRIC_SMOOTHING: ::std::os::raw::c_uint = 8;
pub const FT_VALIDATE_feat_INDEX: ::std::os::raw::c_uint = 0;
pub const FT_VALIDATE_mort_INDEX: ::std::os::raw::c_uint = 1;
pub const FT_VALIDATE_morx_INDEX: ::std::os::raw::c_uint = 2;
pub const FT_VALIDATE_bsln_INDEX: ::std::os::raw::c_uint = 3;
pub const FT_VALIDATE_just_INDEX: ::std::os::raw::c_uint = 4;
pub const FT_VALIDATE_kern_INDEX: ::std::os::raw::c_uint = 5;
pub const FT_VALIDATE_opbd_INDEX: ::std::os::raw::c_uint = 6;
pub const FT_VALIDATE_trak_INDEX: ::std::os::raw::c_uint = 7;
pub const FT_VALIDATE_prop_INDEX: ::std::os::raw::c_uint = 8;
pub const FT_VALIDATE_lcar_INDEX: ::std::os::raw::c_uint = 9;
pub const FT_VALIDATE_GX_LAST_INDEX: ::std::os::raw::c_uint = 9;
pub const FT_VALIDATE_GX_LENGTH: ::std::os::raw::c_uint = 10;
pub const FT_VALIDATE_GX_START: ::std::os::raw::c_uint = 16384;
pub const FT_VALIDATE_MS: ::std::os::raw::c_uint = 16384;
pub const FT_VALIDATE_APPLE: ::std::os::raw::c_uint = 32768;
pub const FT_VALIDATE_CKERN: ::std::os::raw::c_uint = 49152;
pub const FT_LCD_FILTER_FIVE_TAPS: ::std::os::raw::c_uint = 5;
pub const FT_VAR_AXIS_FLAG_HIDDEN: ::std::os::raw::c_uint = 1;
pub const FT_MODULE_FONT_DRIVER: ::std::os::raw::c_uint = 1;
pub const FT_MODULE_RENDERER: ::std::os::raw::c_uint = 2;
pub const FT_MODULE_HINTER: ::std::os::raw::c_uint = 4;
pub const FT_MODULE_STYLER: ::std::os::raw::c_uint = 8;
pub const FT_MODULE_DRIVER_SCALABLE: ::std::os::raw::c_uint = 256;
pub const FT_MODULE_DRIVER_NO_OUTLINES: ::std::os::raw::c_uint = 512;
pub const FT_MODULE_DRIVER_HAS_HINTER: ::std::os::raw::c_uint = 1024;
pub const FT_MODULE_DRIVER_HINTS_LIGHTLY: ::std::os::raw::c_uint = 2048;
pub const FT_VALIDATE_BASE: ::std::os::raw::c_uint = 256;
pub const FT_VALIDATE_GDEF: ::std::os::raw::c_uint = 512;
pub const FT_VALIDATE_GPOS: ::std::os::raw::c_uint = 1024;
pub const FT_VALIDATE_GSUB: ::std::os::raw::c_uint = 2048;
pub const FT_VALIDATE_JSTF: ::std::os::raw::c_uint = 4096;
pub const FT_VALIDATE_MATH: ::std::os::raw::c_uint = 8192;
pub const FT_VALIDATE_OT: ::std::os::raw::c_uint = 16128;
pub const FT_T1_HINTING_FREETYPE: ::std::os::raw::c_uint = 0;
pub const FT_T1_HINTING_ADOBE: ::std::os::raw::c_uint = 1;
pub const FT_ANGLE_PI: ::std::os::raw::c_uint = 11796480;
pub const FT_ANGLE_2PI: ::std::os::raw::c_uint = 23592960;
pub const FT_ANGLE_PI2: ::std::os::raw::c_uint = 5898240;
pub const FT_ANGLE_PI4: ::std::os::raw::c_uint = 2949120;
pub const FT_WinFNT_ID_CP1252: ::std::os::raw::c_uint = 0;
pub const FT_WinFNT_ID_DEFAULT: ::std::os::raw::c_uint = 1;
pub const FT_WinFNT_ID_SYMBOL: ::std::os::raw::c_uint = 2;
pub const FT_WinFNT_ID_MAC: ::std::os::raw::c_uint = 77;
pub const FT_WinFNT_ID_CP932: ::std::os::raw::c_uint = 128;
pub const FT_WinFNT_ID_CP949: ::std::os::raw::c_uint = 129;
pub const FT_WinFNT_ID_CP1361: ::std::os::raw::c_uint = 130;
pub const FT_WinFNT_ID_CP936: ::std::os::raw::c_uint = 134;
pub const FT_WinFNT_ID_CP950: ::std::os::raw::c_uint = 136;
pub const FT_WinFNT_ID_CP1253: ::std::os::raw::c_uint = 161;
pub const FT_WinFNT_ID_CP1254: ::std::os::raw::c_uint = 162;
pub const FT_WinFNT_ID_CP1258: ::std::os::raw::c_uint = 163;
pub const FT_WinFNT_ID_CP1255: ::std::os::raw::c_uint = 177;
pub const FT_WinFNT_ID_CP1256: ::std::os::raw::c_uint = 178;
pub const FT_WinFNT_ID_CP1257: ::std::os::raw::c_uint = 186;
pub const FT_WinFNT_ID_CP1251: ::std::os::raw::c_uint = 204;
pub const FT_WinFNT_ID_CP874: ::std::os::raw::c_uint = 222;
pub const FT_WinFNT_ID_CP1250: ::std::os::raw::c_uint = 238;
pub const FT_WinFNT_ID_OEM: ::std::os::raw::c_uint = 255;
pub type FT_Fast = ::std::os::raw::c_int;
pub type FT_UFast = ::std::os::raw::c_uint;
/// @type:
/// FT_Memory
///
/// @description:
/// A handle to a given memory manager object, defined with an
/// @FT_MemoryRec structure.
///
pub type FT_Memory = *mut FT_MemoryRec_;
/// @functype:
/// FT_Alloc_Func
///
/// @description:
/// A function used to allocate `size' bytes from `memory'.
///
/// @input:
/// memory ::
/// A handle to the source memory manager.
///
/// size ::
/// The size in bytes to allocate.
///
/// @return:
/// Address of new memory block.  0~in case of failure.
///
pub type FT_Alloc_Func = ::std::option::Option<
    unsafe extern "C" fn(memory: FT_Memory, size: ::std::os::raw::c_long)
        -> *mut ::std::os::raw::c_void,
>;
/// @functype:
/// FT_Free_Func
///
/// @description:
/// A function used to release a given block of memory.
///
/// @input:
/// memory ::
/// A handle to the source memory manager.
///
/// block ::
/// The address of the target memory block.
///
pub type FT_Free_Func = ::std::option::Option<
    unsafe extern "C" fn(memory: FT_Memory, block: *mut ::std::os::raw::c_void),
>;
/// @functype:
/// FT_Realloc_Func
///
/// @description:
/// A function used to re-allocate a given block of memory.
///
/// @input:
/// memory ::
/// A handle to the source memory manager.
///
/// cur_size ::
/// The block's current size in bytes.
///
/// new_size ::
/// The block's requested new size.
///
/// block ::
/// The block's current address.
///
/// @return:
/// New block address.  0~in case of memory shortage.
///
/// @note:
/// In case of error, the old block must still be available.
///
pub type FT_Realloc_Func = ::std::option::Option<
    unsafe extern "C" fn(
        memory: FT_Memory,
        cur_size: ::std::os::raw::c_long,
        new_size: ::std::os::raw::c_long,
        block: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
/// @struct:
/// FT_MemoryRec
///
/// @description:
/// A structure used to describe a given memory manager to FreeType~2.
///
/// @fields:
/// user ::
/// A generic typeless pointer for user data.
///
/// alloc ::
/// A pointer type to an allocation function.
///
/// free ::
/// A pointer type to an memory freeing function.
///
/// realloc ::
/// A pointer type to a reallocation function.
///
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_MemoryRec_ {
    pub user: *mut ::std::os::raw::c_void,
    pub alloc: FT_Alloc_Func,
    pub free: FT_Free_Func,
    pub realloc: FT_Realloc_Func,
}
#[test]
fn bindgen_test_layout_FT_MemoryRec_() {
    assert_eq!(
        ::std::mem::size_of::<FT_MemoryRec_>(),
        32usize,
        concat!("Size of: ", stringify!(FT_MemoryRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_MemoryRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_MemoryRec_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_MemoryRec_)).user as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_MemoryRec_),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_MemoryRec_)).alloc as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_MemoryRec_),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_MemoryRec_)).free as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_MemoryRec_),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_MemoryRec_)).realloc as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_MemoryRec_),
            "::",
            stringify!(realloc)
        )
    );
}
/// @type:
/// FT_Stream
///
/// @description:
/// A handle to an input stream.
///
/// @also:
/// See @FT_StreamRec for the publicly accessible fields of a given
/// stream object.
///
pub type FT_Stream = *mut FT_StreamRec_;
/// @struct:
/// FT_StreamDesc
///
/// @description:
/// A union type used to store either a long or a pointer.  This is used
/// to store a file descriptor or a `FILE*' in an input stream.
///
#[repr(C)]
#[derive(Copy, Clone)]
pub union FT_StreamDesc_ {
    pub value: ::std::os::raw::c_long,
    pub pointer: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_FT_StreamDesc_() {
    assert_eq!(
        ::std::mem::size_of::<FT_StreamDesc_>(),
        8usize,
        concat!("Size of: ", stringify!(FT_StreamDesc_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_StreamDesc_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_StreamDesc_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_StreamDesc_)).value as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_StreamDesc_),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_StreamDesc_)).pointer as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_StreamDesc_),
            "::",
            stringify!(pointer)
        )
    );
}
pub type FT_StreamDesc = FT_StreamDesc_;
/// @functype:
/// FT_Stream_IoFunc
///
/// @description:
/// A function used to seek and read data from a given input stream.
///
/// @input:
/// stream ::
/// A handle to the source stream.
///
/// offset ::
/// The offset of read in stream (always from start).
///
/// buffer ::
/// The address of the read buffer.
///
/// count ::
/// The number of bytes to read from the stream.
///
/// @return:
/// The number of bytes effectively read by the stream.
///
/// @note:
/// This function might be called to perform a seek or skip operation
/// with a `count' of~0.  A non-zero return value then indicates an
/// error.
///
pub type FT_Stream_IoFunc = ::std::option::Option<
    unsafe extern "C" fn(
        stream: FT_Stream,
        offset: ::std::os::raw::c_ulong,
        buffer: *mut ::std::os::raw::c_uchar,
        count: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong,
>;
/// @functype:
/// FT_Stream_CloseFunc
///
/// @description:
/// A function used to close a given input stream.
///
/// @input:
/// stream ::
/// A handle to the target stream.
///
pub type FT_Stream_CloseFunc = ::std::option::Option<unsafe extern "C" fn(stream: FT_Stream)>;
/// @struct:
/// FT_StreamRec
///
/// @description:
/// A structure used to describe an input stream.
///
/// @input:
/// base ::
/// For memory-based streams, this is the address of the first stream
/// byte in memory.  This field should always be set to NULL for
/// disk-based streams.
///
/// size ::
/// The stream size in bytes.
///
/// In case of compressed streams where the size is unknown before
/// actually doing the decompression, the value is set to 0x7FFFFFFF.
/// (Note that this size value can occur for normal streams also; it is
/// thus just a hint.)
///
/// pos ::
/// The current position within the stream.
///
/// descriptor ::
/// This field is a union that can hold an integer or a pointer.  It is
/// used by stream implementations to store file descriptors or `FILE*'
/// pointers.
///
/// pathname ::
/// This field is completely ignored by FreeType.  However, it is often
/// useful during debugging to use it to store the stream's filename
/// (where available).
///
/// read ::
/// The stream's input function.
///
/// close ::
/// The stream's close function.
///
/// memory ::
/// The memory manager to use to preload frames.  This is set
/// internally by FreeType and shouldn't be touched by stream
/// implementations.
///
/// cursor ::
/// This field is set and used internally by FreeType when parsing
/// frames.
///
/// limit ::
/// This field is set and used internally by FreeType when parsing
/// frames.
///
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FT_StreamRec_ {
    pub base: *mut ::std::os::raw::c_uchar,
    pub size: ::std::os::raw::c_ulong,
    pub pos: ::std::os::raw::c_ulong,
    pub descriptor: FT_StreamDesc,
    pub pathname: FT_StreamDesc,
    pub read: FT_Stream_IoFunc,
    pub close: FT_Stream_CloseFunc,
    pub memory: FT_Memory,
    pub cursor: *mut ::std::os::raw::c_uchar,
    pub limit: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_FT_StreamRec_() {
    assert_eq!(
        ::std::mem::size_of::<FT_StreamRec_>(),
        72usize,
        concat!("Size of: ", stringify!(FT_StreamRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_StreamRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_StreamRec_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_StreamRec_)).base as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_StreamRec_),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_StreamRec_)).size as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_StreamRec_),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_StreamRec_)).pos as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_StreamRec_),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_StreamRec_)).descriptor as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_StreamRec_),
            "::",
            stringify!(descriptor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_StreamRec_)).pathname as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_StreamRec_),
            "::",
            stringify!(pathname)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_StreamRec_)).read as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_StreamRec_),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_StreamRec_)).close as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_StreamRec_),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_StreamRec_)).memory as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_StreamRec_),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_StreamRec_)).cursor as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_StreamRec_),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_StreamRec_)).limit as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_StreamRec_),
            "::",
            stringify!(limit)
        )
    );
}
pub type FT_StreamRec = FT_StreamRec_;

pub type FT_Pos = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Vector_ {
    pub x: FT_Pos,
    pub y: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_Vector_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Vector_>(),
        8usize,
        concat!("Size of: ", stringify!(FT_Vector_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Vector_>(),
        4usize,
        concat!("Alignment of ", stringify!(FT_Vector_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Vector_)).x as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Vector_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Vector_)).y as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Vector_),
            "::",
            stringify!(y)
        )
    );
}
pub type FT_Vector = FT_Vector_;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_BBox_ {
    pub xMin: FT_Pos,
    pub yMin: FT_Pos,
    pub xMax: FT_Pos,
    pub yMax: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_BBox_() {
    assert_eq!(
        ::std::mem::size_of::<FT_BBox_>(),
        16usize,
        concat!("Size of: ", stringify!(FT_BBox_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_BBox_>(),
        4usize,
        concat!("Alignment of ", stringify!(FT_BBox_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_BBox_)).xMin as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_BBox_),
            "::",
            stringify!(xMin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_BBox_)).yMin as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_BBox_),
            "::",
            stringify!(yMin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_BBox_)).xMax as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_BBox_),
            "::",
            stringify!(xMax)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_BBox_)).yMax as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_BBox_),
            "::",
            stringify!(yMax)
        )
    );
}
pub type FT_BBox = FT_BBox_;
pub const FT_Pixel_Mode__FT_PIXEL_MODE_NONE: FT_Pixel_Mode_ = 0;
pub const FT_Pixel_Mode__FT_PIXEL_MODE_MONO: FT_Pixel_Mode_ = 1;
pub const FT_Pixel_Mode__FT_PIXEL_MODE_GRAY: FT_Pixel_Mode_ = 2;
pub const FT_Pixel_Mode__FT_PIXEL_MODE_GRAY2: FT_Pixel_Mode_ = 3;
pub const FT_Pixel_Mode__FT_PIXEL_MODE_GRAY4: FT_Pixel_Mode_ = 4;
pub const FT_Pixel_Mode__FT_PIXEL_MODE_LCD: FT_Pixel_Mode_ = 5;
pub const FT_Pixel_Mode__FT_PIXEL_MODE_LCD_V: FT_Pixel_Mode_ = 6;
pub const FT_Pixel_Mode__FT_PIXEL_MODE_BGRA: FT_Pixel_Mode_ = 7;
pub const FT_Pixel_Mode__FT_PIXEL_MODE_MAX: FT_Pixel_Mode_ = 8;
pub type FT_Pixel_Mode_ = ::std::os::raw::c_int;
pub use self::FT_Pixel_Mode_ as FT_Pixel_Mode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Bitmap_ {
    pub rows: ::std::os::raw::c_uint,
    pub width: ::std::os::raw::c_uint,
    pub pitch: ::std::os::raw::c_int,
    pub buffer: *mut ::std::os::raw::c_uchar,
    pub num_grays: ::std::os::raw::c_ushort,
    pub pixel_mode: ::std::os::raw::c_uchar,
    pub palette_mode: ::std::os::raw::c_uchar,
    pub palette: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FT_Bitmap_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Bitmap_>(),
        40usize,
        concat!("Size of: ", stringify!(FT_Bitmap_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Bitmap_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Bitmap_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Bitmap_)).rows as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Bitmap_),
            "::",
            stringify!(rows)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Bitmap_)).width as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Bitmap_),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Bitmap_)).pitch as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Bitmap_),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Bitmap_)).buffer as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Bitmap_),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Bitmap_)).num_grays as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Bitmap_),
            "::",
            stringify!(num_grays)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Bitmap_)).pixel_mode as *const _ as usize },
        26usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Bitmap_),
            "::",
            stringify!(pixel_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Bitmap_)).palette_mode as *const _ as usize },
        27usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Bitmap_),
            "::",
            stringify!(palette_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Bitmap_)).palette as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Bitmap_),
            "::",
            stringify!(palette)
        )
    );
}
pub type FT_Bitmap = FT_Bitmap_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Outline_ {
    pub n_contours: ::std::os::raw::c_short,
    pub n_points: ::std::os::raw::c_short,
    pub points: *mut FT_Vector,
    pub tags: *mut ::std::os::raw::c_char,
    pub contours: *mut ::std::os::raw::c_short,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FT_Outline_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Outline_>(),
        40usize,
        concat!("Size of: ", stringify!(FT_Outline_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Outline_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Outline_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Outline_)).n_contours as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Outline_),
            "::",
            stringify!(n_contours)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Outline_)).n_points as *const _ as usize },
        2usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Outline_),
            "::",
            stringify!(n_points)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Outline_)).points as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Outline_),
            "::",
            stringify!(points)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Outline_)).tags as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Outline_),
            "::",
            stringify!(tags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Outline_)).contours as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Outline_),
            "::",
            stringify!(contours)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Outline_)).flags as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Outline_),
            "::",
            stringify!(flags)
        )
    );
}
pub type FT_Outline = FT_Outline_;

pub type FT_Outline_MoveToFunc = ::std::option::Option<
    unsafe extern "C" fn(to: *const FT_Vector, user: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int,
>;

pub type FT_Outline_LineToFunc = ::std::option::Option<
    unsafe extern "C" fn(to: *const FT_Vector, user: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int,
>;

pub type FT_Outline_ConicToFunc = ::std::option::Option<
    unsafe extern "C" fn(
        control: *const FT_Vector,
        to: *const FT_Vector,
        user: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;

pub type FT_Outline_CubicToFunc = ::std::option::Option<
    unsafe extern "C" fn(
        control1: *const FT_Vector,
        control2: *const FT_Vector,
        to: *const FT_Vector,
        user: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Outline_Funcs_ {
    pub move_to: FT_Outline_MoveToFunc,
    pub line_to: FT_Outline_LineToFunc,
    pub conic_to: FT_Outline_ConicToFunc,
    pub cubic_to: FT_Outline_CubicToFunc,
    pub shift: ::std::os::raw::c_int,
    pub delta: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_Outline_Funcs_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Outline_Funcs_>(),
        40usize,
        concat!("Size of: ", stringify!(FT_Outline_Funcs_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Outline_Funcs_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Outline_Funcs_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Outline_Funcs_)).move_to as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Outline_Funcs_),
            "::",
            stringify!(move_to)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Outline_Funcs_)).line_to as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Outline_Funcs_),
            "::",
            stringify!(line_to)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Outline_Funcs_)).conic_to as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Outline_Funcs_),
            "::",
            stringify!(conic_to)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Outline_Funcs_)).cubic_to as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Outline_Funcs_),
            "::",
            stringify!(cubic_to)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Outline_Funcs_)).shift as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Outline_Funcs_),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Outline_Funcs_)).delta as *const _ as usize },
        36usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Outline_Funcs_),
            "::",
            stringify!(delta)
        )
    );
}
pub type FT_Outline_Funcs = FT_Outline_Funcs_;
pub const FT_Glyph_Format__FT_GLYPH_FORMAT_NONE: FT_Glyph_Format_ = 0;
pub const FT_Glyph_Format__FT_GLYPH_FORMAT_COMPOSITE: FT_Glyph_Format_ = 1668246896;
pub const FT_Glyph_Format__FT_GLYPH_FORMAT_BITMAP: FT_Glyph_Format_ = 1651078259;
pub const FT_Glyph_Format__FT_GLYPH_FORMAT_OUTLINE: FT_Glyph_Format_ = 1869968492;
pub const FT_Glyph_Format__FT_GLYPH_FORMAT_PLOTTER: FT_Glyph_Format_ = 1886154612;
pub type FT_Glyph_Format_ = ::std::os::raw::c_int;
pub use self::FT_Glyph_Format_ as FT_Glyph_Format;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_RasterRec_ {
    _unused: [u8; 0],
}

pub type FT_Raster = *mut FT_RasterRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Span_ {
    pub x: ::std::os::raw::c_short,
    pub len: ::std::os::raw::c_ushort,
    pub coverage: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_FT_Span_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Span_>(),
        6usize,
        concat!("Size of: ", stringify!(FT_Span_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Span_>(),
        2usize,
        concat!("Alignment of ", stringify!(FT_Span_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Span_)).x as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Span_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Span_)).len as *const _ as usize },
        2usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Span_),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Span_)).coverage as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Span_),
            "::",
            stringify!(coverage)
        )
    );
}
pub type FT_Span = FT_Span_;

pub type FT_SpanFunc = ::std::option::Option<
    unsafe extern "C" fn(
        y: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        spans: *const FT_Span,
        user: *mut ::std::os::raw::c_void,
    ),
>;

pub type FT_Raster_BitTest_Func = ::std::option::Option<
    unsafe extern "C" fn(
        y: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        user: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;

pub type FT_Raster_BitSet_Func = ::std::option::Option<
    unsafe extern "C" fn(
        y: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        user: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Raster_Params_ {
    pub target: *const FT_Bitmap,
    pub source: *const ::std::os::raw::c_void,
    pub flags: ::std::os::raw::c_int,
    pub gray_spans: FT_SpanFunc,
    pub black_spans: FT_SpanFunc,
    pub bit_test: FT_Raster_BitTest_Func,
    pub bit_set: FT_Raster_BitSet_Func,
    pub user: *mut ::std::os::raw::c_void,
    pub clip_box: FT_BBox,
}
#[test]
fn bindgen_test_layout_FT_Raster_Params_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Raster_Params_>(),
        80usize,
        concat!("Size of: ", stringify!(FT_Raster_Params_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Raster_Params_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Raster_Params_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Raster_Params_)).target as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Raster_Params_),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Raster_Params_)).source as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Raster_Params_),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Raster_Params_)).flags as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Raster_Params_),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Raster_Params_)).gray_spans as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Raster_Params_),
            "::",
            stringify!(gray_spans)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Raster_Params_)).black_spans as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Raster_Params_),
            "::",
            stringify!(black_spans)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Raster_Params_)).bit_test as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Raster_Params_),
            "::",
            stringify!(bit_test)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Raster_Params_)).bit_set as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Raster_Params_),
            "::",
            stringify!(bit_set)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Raster_Params_)).user as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Raster_Params_),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Raster_Params_)).clip_box as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Raster_Params_),
            "::",
            stringify!(clip_box)
        )
    );
}
pub type FT_Raster_Params = FT_Raster_Params_;
pub type FT_Raster_NewFunc = ::std::option::Option<
    unsafe extern "C" fn(memory: *mut ::std::os::raw::c_void, raster: *mut FT_Raster)
        -> ::std::os::raw::c_int,
>;

pub type FT_Raster_DoneFunc = ::std::option::Option<unsafe extern "C" fn(raster: FT_Raster)>;

pub type FT_Raster_ResetFunc = ::std::option::Option<
    unsafe extern "C" fn(
        raster: FT_Raster,
        pool_base: *mut ::std::os::raw::c_uchar,
        pool_size: ::std::os::raw::c_ulong,
    ),
>;

pub type FT_Raster_SetModeFunc = ::std::option::Option<
    unsafe extern "C" fn(
        raster: FT_Raster,
        mode: ::std::os::raw::c_ulong,
        args: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type FT_Raster_RenderFunc = ::std::option::Option<
    unsafe extern "C" fn(raster: FT_Raster, params: *const FT_Raster_Params)
        -> ::std::os::raw::c_int,
>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Raster_Funcs_ {
    pub glyph_format: FT_Glyph_Format,
    pub raster_new: FT_Raster_NewFunc,
    pub raster_reset: FT_Raster_ResetFunc,
    pub raster_set_mode: FT_Raster_SetModeFunc,
    pub raster_render: FT_Raster_RenderFunc,
    pub raster_done: FT_Raster_DoneFunc,
}
#[test]
fn bindgen_test_layout_FT_Raster_Funcs_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Raster_Funcs_>(),
        48usize,
        concat!("Size of: ", stringify!(FT_Raster_Funcs_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Raster_Funcs_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Raster_Funcs_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Raster_Funcs_)).glyph_format as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Raster_Funcs_),
            "::",
            stringify!(glyph_format)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Raster_Funcs_)).raster_new as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Raster_Funcs_),
            "::",
            stringify!(raster_new)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Raster_Funcs_)).raster_reset as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Raster_Funcs_),
            "::",
            stringify!(raster_reset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Raster_Funcs_)).raster_set_mode as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Raster_Funcs_),
            "::",
            stringify!(raster_set_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Raster_Funcs_)).raster_render as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Raster_Funcs_),
            "::",
            stringify!(raster_render)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Raster_Funcs_)).raster_done as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Raster_Funcs_),
            "::",
            stringify!(raster_done)
        )
    );
}
pub type FT_Raster_Funcs = FT_Raster_Funcs_;

pub type FT_Bool = ::std::os::raw::c_uchar;

pub type FT_FWord = ::std::os::raw::c_short;

pub type FT_UFWord = ::std::os::raw::c_ushort;

pub type FT_Char = ::std::os::raw::c_schar;

pub type FT_Byte = ::std::os::raw::c_uchar;

pub type FT_Bytes = *const FT_Byte;

pub type FT_Tag = FT_UInt32;

pub type FT_String = ::std::os::raw::c_char;

pub type FT_Short = ::std::os::raw::c_short;

pub type FT_UShort = ::std::os::raw::c_ushort;

pub type FT_Int = ::std::os::raw::c_int;

pub type FT_UInt = ::std::os::raw::c_uint;

pub type FT_Long = ::std::os::raw::c_long;

pub type FT_ULong = ::std::os::raw::c_ulong;

pub type FT_F2Dot14 = ::std::os::raw::c_short;

pub type FT_F26Dot6 = ::std::os::raw::c_long;

pub type FT_Fixed = ::std::os::raw::c_long;

pub type FT_Pointer = *mut ::std::os::raw::c_void;

pub type FT_Offset = usize;

pub type FT_PtrDist = isize;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_UnitVector_ {
    pub x: FT_F2Dot14,
    pub y: FT_F2Dot14,
}
#[test]
fn bindgen_test_layout_FT_UnitVector_() {
    assert_eq!(
        ::std::mem::size_of::<FT_UnitVector_>(),
        4usize,
        concat!("Size of: ", stringify!(FT_UnitVector_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_UnitVector_>(),
        2usize,
        concat!("Alignment of ", stringify!(FT_UnitVector_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_UnitVector_)).x as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_UnitVector_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_UnitVector_)).y as *const _ as usize },
        2usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_UnitVector_),
            "::",
            stringify!(y)
        )
    );
}
pub type FT_UnitVector = FT_UnitVector_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Matrix_ {
    pub xx: FT_Fixed,
    pub xy: FT_Fixed,
    pub yx: FT_Fixed,
    pub yy: FT_Fixed,
}
#[test]
fn bindgen_test_layout_FT_Matrix_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Matrix_>(),
        16usize,
        concat!("Size of: ", stringify!(FT_Matrix_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Matrix_>(),
        4usize,
        concat!("Alignment of ", stringify!(FT_Matrix_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Matrix_)).xx as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Matrix_),
            "::",
            stringify!(xx)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Matrix_)).xy as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Matrix_),
            "::",
            stringify!(xy)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Matrix_)).yx as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Matrix_),
            "::",
            stringify!(yx)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Matrix_)).yy as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Matrix_),
            "::",
            stringify!(yy)
        )
    );
}
pub type FT_Matrix = FT_Matrix_;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Data_ {
    pub pointer: *const FT_Byte,
    pub length: FT_Int,
}
#[test]
fn bindgen_test_layout_FT_Data_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Data_>(),
        16usize,
        concat!("Size of: ", stringify!(FT_Data_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Data_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Data_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Data_)).pointer as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Data_),
            "::",
            stringify!(pointer)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Data_)).length as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Data_),
            "::",
            stringify!(length)
        )
    );
}
pub type FT_Data = FT_Data_;
pub type FT_Generic_Finalizer = ::std::option::Option<
    unsafe extern "C" fn(object: *mut ::std::os::raw::c_void),
>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Generic_ {
    pub data: *mut ::std::os::raw::c_void,
    pub finalizer: FT_Generic_Finalizer,
}
#[test]
fn bindgen_test_layout_FT_Generic_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Generic_>(),
        16usize,
        concat!("Size of: ", stringify!(FT_Generic_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Generic_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Generic_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Generic_)).data as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Generic_),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Generic_)).finalizer as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Generic_),
            "::",
            stringify!(finalizer)
        )
    );
}
pub type FT_Generic = FT_Generic_;
pub type FT_ListNode = *mut FT_ListNodeRec_;
pub type FT_List = *mut FT_ListRec_;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_ListNodeRec_ {
    pub prev: FT_ListNode,
    pub next: FT_ListNode,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FT_ListNodeRec_() {
    assert_eq!(
        ::std::mem::size_of::<FT_ListNodeRec_>(),
        24usize,
        concat!("Size of: ", stringify!(FT_ListNodeRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_ListNodeRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_ListNodeRec_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_ListNodeRec_)).prev as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_ListNodeRec_),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_ListNodeRec_)).next as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_ListNodeRec_),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_ListNodeRec_)).data as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_ListNodeRec_),
            "::",
            stringify!(data)
        )
    );
}
pub type FT_ListNodeRec = FT_ListNodeRec_;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_ListRec_ {
    pub head: FT_ListNode,
    pub tail: FT_ListNode,
}
#[test]
fn bindgen_test_layout_FT_ListRec_() {
    assert_eq!(
        ::std::mem::size_of::<FT_ListRec_>(),
        16usize,
        concat!("Size of: ", stringify!(FT_ListRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_ListRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_ListRec_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_ListRec_)).head as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_ListRec_),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_ListRec_)).tail as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_ListRec_),
            "::",
            stringify!(tail)
        )
    );
}
pub type FT_ListRec = FT_ListRec_;
pub const FT_Mod_Err_Base: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Autofit: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_BDF: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Bzip2: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Cache: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_CFF: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_CID: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Gzip: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_LZW: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_OTvalid: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_PCF: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_PFR: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_PSaux: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_PShinter: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_PSnames: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Raster: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_SFNT: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Smooth: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_TrueType: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Type1: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Type42: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Winfonts: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_GXvalid: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Max: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
pub const FT_Err_Ok: _bindgen_ty_2 = 0;
pub const FT_Err_Cannot_Open_Resource: _bindgen_ty_2 = 1;
pub const FT_Err_Unknown_File_Format: _bindgen_ty_2 = 2;
pub const FT_Err_Invalid_File_Format: _bindgen_ty_2 = 3;
pub const FT_Err_Invalid_Version: _bindgen_ty_2 = 4;
pub const FT_Err_Lower_Module_Version: _bindgen_ty_2 = 5;
pub const FT_Err_Invalid_Argument: _bindgen_ty_2 = 6;
pub const FT_Err_Unimplemented_Feature: _bindgen_ty_2 = 7;
pub const FT_Err_Invalid_Table: _bindgen_ty_2 = 8;
pub const FT_Err_Invalid_Offset: _bindgen_ty_2 = 9;
pub const FT_Err_Array_Too_Large: _bindgen_ty_2 = 10;
pub const FT_Err_Missing_Module: _bindgen_ty_2 = 11;
pub const FT_Err_Missing_Property: _bindgen_ty_2 = 12;
pub const FT_Err_Invalid_Glyph_Index: _bindgen_ty_2 = 16;
pub const FT_Err_Invalid_Character_Code: _bindgen_ty_2 = 17;
pub const FT_Err_Invalid_Glyph_Format: _bindgen_ty_2 = 18;
pub const FT_Err_Cannot_Render_Glyph: _bindgen_ty_2 = 19;
pub const FT_Err_Invalid_Outline: _bindgen_ty_2 = 20;
pub const FT_Err_Invalid_Composite: _bindgen_ty_2 = 21;
pub const FT_Err_Too_Many_Hints: _bindgen_ty_2 = 22;
pub const FT_Err_Invalid_Pixel_Size: _bindgen_ty_2 = 23;
pub const FT_Err_Invalid_Handle: _bindgen_ty_2 = 32;
pub const FT_Err_Invalid_Library_Handle: _bindgen_ty_2 = 33;
pub const FT_Err_Invalid_Driver_Handle: _bindgen_ty_2 = 34;
pub const FT_Err_Invalid_Face_Handle: _bindgen_ty_2 = 35;
pub const FT_Err_Invalid_Size_Handle: _bindgen_ty_2 = 36;
pub const FT_Err_Invalid_Slot_Handle: _bindgen_ty_2 = 37;
pub const FT_Err_Invalid_CharMap_Handle: _bindgen_ty_2 = 38;
pub const FT_Err_Invalid_Cache_Handle: _bindgen_ty_2 = 39;
pub const FT_Err_Invalid_Stream_Handle: _bindgen_ty_2 = 40;
pub const FT_Err_Too_Many_Drivers: _bindgen_ty_2 = 48;
pub const FT_Err_Too_Many_Extensions: _bindgen_ty_2 = 49;
pub const FT_Err_Out_Of_Memory: _bindgen_ty_2 = 64;
pub const FT_Err_Unlisted_Object: _bindgen_ty_2 = 65;
pub const FT_Err_Cannot_Open_Stream: _bindgen_ty_2 = 81;
pub const FT_Err_Invalid_Stream_Seek: _bindgen_ty_2 = 82;
pub const FT_Err_Invalid_Stream_Skip: _bindgen_ty_2 = 83;
pub const FT_Err_Invalid_Stream_Read: _bindgen_ty_2 = 84;
pub const FT_Err_Invalid_Stream_Operation: _bindgen_ty_2 = 85;
pub const FT_Err_Invalid_Frame_Operation: _bindgen_ty_2 = 86;
pub const FT_Err_Nested_Frame_Access: _bindgen_ty_2 = 87;
pub const FT_Err_Invalid_Frame_Read: _bindgen_ty_2 = 88;
pub const FT_Err_Raster_Uninitialized: _bindgen_ty_2 = 96;
pub const FT_Err_Raster_Corrupted: _bindgen_ty_2 = 97;
pub const FT_Err_Raster_Overflow: _bindgen_ty_2 = 98;
pub const FT_Err_Raster_Negative_Height: _bindgen_ty_2 = 99;
pub const FT_Err_Too_Many_Caches: _bindgen_ty_2 = 112;
pub const FT_Err_Invalid_Opcode: _bindgen_ty_2 = 128;
pub const FT_Err_Too_Few_Arguments: _bindgen_ty_2 = 129;
pub const FT_Err_Stack_Overflow: _bindgen_ty_2 = 130;
pub const FT_Err_Code_Overflow: _bindgen_ty_2 = 131;
pub const FT_Err_Bad_Argument: _bindgen_ty_2 = 132;
pub const FT_Err_Divide_By_Zero: _bindgen_ty_2 = 133;
pub const FT_Err_Invalid_Reference: _bindgen_ty_2 = 134;
pub const FT_Err_Debug_OpCode: _bindgen_ty_2 = 135;
pub const FT_Err_ENDF_In_Exec_Stream: _bindgen_ty_2 = 136;
pub const FT_Err_Nested_DEFS: _bindgen_ty_2 = 137;
pub const FT_Err_Invalid_CodeRange: _bindgen_ty_2 = 138;
pub const FT_Err_Execution_Too_Long: _bindgen_ty_2 = 139;
pub const FT_Err_Too_Many_Function_Defs: _bindgen_ty_2 = 140;
pub const FT_Err_Too_Many_Instruction_Defs: _bindgen_ty_2 = 141;
pub const FT_Err_Table_Missing: _bindgen_ty_2 = 142;
pub const FT_Err_Horiz_Header_Missing: _bindgen_ty_2 = 143;
pub const FT_Err_Locations_Missing: _bindgen_ty_2 = 144;
pub const FT_Err_Name_Table_Missing: _bindgen_ty_2 = 145;
pub const FT_Err_CMap_Table_Missing: _bindgen_ty_2 = 146;
pub const FT_Err_Hmtx_Table_Missing: _bindgen_ty_2 = 147;
pub const FT_Err_Post_Table_Missing: _bindgen_ty_2 = 148;
pub const FT_Err_Invalid_Horiz_Metrics: _bindgen_ty_2 = 149;
pub const FT_Err_Invalid_CharMap_Format: _bindgen_ty_2 = 150;
pub const FT_Err_Invalid_PPem: _bindgen_ty_2 = 151;
pub const FT_Err_Invalid_Vert_Metrics: _bindgen_ty_2 = 152;
pub const FT_Err_Could_Not_Find_Context: _bindgen_ty_2 = 153;
pub const FT_Err_Invalid_Post_Table_Format: _bindgen_ty_2 = 154;
pub const FT_Err_Invalid_Post_Table: _bindgen_ty_2 = 155;
pub const FT_Err_DEF_In_Glyf_Bytecode: _bindgen_ty_2 = 156;
pub const FT_Err_Missing_Bitmap: _bindgen_ty_2 = 157;
pub const FT_Err_Syntax_Error: _bindgen_ty_2 = 160;
pub const FT_Err_Stack_Underflow: _bindgen_ty_2 = 161;
pub const FT_Err_Ignore: _bindgen_ty_2 = 162;
pub const FT_Err_No_Unicode_Glyph_Name: _bindgen_ty_2 = 163;
pub const FT_Err_Glyph_Too_Big: _bindgen_ty_2 = 164;
pub const FT_Err_Missing_Startfont_Field: _bindgen_ty_2 = 176;
pub const FT_Err_Missing_Font_Field: _bindgen_ty_2 = 177;
pub const FT_Err_Missing_Size_Field: _bindgen_ty_2 = 178;
pub const FT_Err_Missing_Fontboundingbox_Field: _bindgen_ty_2 = 179;
pub const FT_Err_Missing_Chars_Field: _bindgen_ty_2 = 180;
pub const FT_Err_Missing_Startchar_Field: _bindgen_ty_2 = 181;
pub const FT_Err_Missing_Encoding_Field: _bindgen_ty_2 = 182;
pub const FT_Err_Missing_Bbx_Field: _bindgen_ty_2 = 183;
pub const FT_Err_Bbx_Too_Big: _bindgen_ty_2 = 184;
pub const FT_Err_Corrupted_Font_Header: _bindgen_ty_2 = 185;
pub const FT_Err_Corrupted_Font_Glyphs: _bindgen_ty_2 = 186;
pub const FT_Err_Max: _bindgen_ty_2 = 187;
pub type _bindgen_ty_2 = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Glyph_Metrics_ {
    pub width: FT_Pos,
    pub height: FT_Pos,
    pub horiBearingX: FT_Pos,
    pub horiBearingY: FT_Pos,
    pub horiAdvance: FT_Pos,
    pub vertBearingX: FT_Pos,
    pub vertBearingY: FT_Pos,
    pub vertAdvance: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_Glyph_Metrics_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Glyph_Metrics_>(),
        32usize,
        concat!("Size of: ", stringify!(FT_Glyph_Metrics_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Glyph_Metrics_>(),
        4usize,
        concat!("Alignment of ", stringify!(FT_Glyph_Metrics_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Glyph_Metrics_)).width as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Glyph_Metrics_),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Glyph_Metrics_)).height as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Glyph_Metrics_),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Glyph_Metrics_)).horiBearingX as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Glyph_Metrics_),
            "::",
            stringify!(horiBearingX)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Glyph_Metrics_)).horiBearingY as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Glyph_Metrics_),
            "::",
            stringify!(horiBearingY)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Glyph_Metrics_)).horiAdvance as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Glyph_Metrics_),
            "::",
            stringify!(horiAdvance)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Glyph_Metrics_)).vertBearingX as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Glyph_Metrics_),
            "::",
            stringify!(vertBearingX)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Glyph_Metrics_)).vertBearingY as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Glyph_Metrics_),
            "::",
            stringify!(vertBearingY)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Glyph_Metrics_)).vertAdvance as *const _ as usize },
        28usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Glyph_Metrics_),
            "::",
            stringify!(vertAdvance)
        )
    );
}
pub type FT_Glyph_Metrics = FT_Glyph_Metrics_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Bitmap_Size_ {
    pub height: FT_Short,
    pub width: FT_Short,
    pub size: FT_Pos,
    pub x_ppem: FT_Pos,
    pub y_ppem: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_Bitmap_Size_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Bitmap_Size_>(),
        16usize,
        concat!("Size of: ", stringify!(FT_Bitmap_Size_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Bitmap_Size_>(),
        4usize,
        concat!("Alignment of ", stringify!(FT_Bitmap_Size_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Bitmap_Size_)).height as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Bitmap_Size_),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Bitmap_Size_)).width as *const _ as usize },
        2usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Bitmap_Size_),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Bitmap_Size_)).size as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Bitmap_Size_),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Bitmap_Size_)).x_ppem as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Bitmap_Size_),
            "::",
            stringify!(x_ppem)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Bitmap_Size_)).y_ppem as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Bitmap_Size_),
            "::",
            stringify!(y_ppem)
        )
    );
}
pub type FT_Bitmap_Size = FT_Bitmap_Size_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_LibraryRec_ {
    _unused: [u8; 0],
}
pub type FT_Library = *mut FT_LibraryRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_ModuleRec_ {
    _unused: [u8; 0],
}

pub type FT_Module = *mut FT_ModuleRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_DriverRec_ {
    _unused: [u8; 0],
}

pub type FT_Driver = *mut FT_DriverRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_RendererRec_ {
    _unused: [u8; 0],
}

pub type FT_Renderer = *mut FT_RendererRec_;
pub type FT_Face = *mut FT_FaceRec_;
pub type FT_Size = *mut FT_SizeRec_;
pub type FT_GlyphSlot = *mut FT_GlyphSlotRec_;
pub type FT_CharMap = *mut FT_CharMapRec_;
pub const FT_Encoding__FT_ENCODING_NONE: FT_Encoding_ = 0;
pub const FT_Encoding__FT_ENCODING_MS_SYMBOL: FT_Encoding_ = 1937337698;
pub const FT_Encoding__FT_ENCODING_UNICODE: FT_Encoding_ = 1970170211;
pub const FT_Encoding__FT_ENCODING_SJIS: FT_Encoding_ = 1936353651;
pub const FT_Encoding__FT_ENCODING_PRC: FT_Encoding_ = 1734484000;
pub const FT_Encoding__FT_ENCODING_BIG5: FT_Encoding_ = 1651074869;
pub const FT_Encoding__FT_ENCODING_WANSUNG: FT_Encoding_ = 2002873971;
pub const FT_Encoding__FT_ENCODING_JOHAB: FT_Encoding_ = 1785686113;
pub const FT_Encoding__FT_ENCODING_GB2312: FT_Encoding_ = 1734484000;
pub const FT_Encoding__FT_ENCODING_MS_SJIS: FT_Encoding_ = 1936353651;
pub const FT_Encoding__FT_ENCODING_MS_GB2312: FT_Encoding_ = 1734484000;
pub const FT_Encoding__FT_ENCODING_MS_BIG5: FT_Encoding_ = 1651074869;
pub const FT_Encoding__FT_ENCODING_MS_WANSUNG: FT_Encoding_ = 2002873971;
pub const FT_Encoding__FT_ENCODING_MS_JOHAB: FT_Encoding_ = 1785686113;
pub const FT_Encoding__FT_ENCODING_ADOBE_STANDARD: FT_Encoding_ = 1094995778;
pub const FT_Encoding__FT_ENCODING_ADOBE_EXPERT: FT_Encoding_ = 1094992453;
pub const FT_Encoding__FT_ENCODING_ADOBE_CUSTOM: FT_Encoding_ = 1094992451;
pub const FT_Encoding__FT_ENCODING_ADOBE_LATIN_1: FT_Encoding_ = 1818326065;
pub const FT_Encoding__FT_ENCODING_OLD_LATIN_2: FT_Encoding_ = 1818326066;
pub const FT_Encoding__FT_ENCODING_APPLE_ROMAN: FT_Encoding_ = 1634889070;
pub type FT_Encoding_ = ::std::os::raw::c_int;
pub use self::FT_Encoding_ as FT_Encoding;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_CharMapRec_ {
    pub face: FT_Face,
    pub encoding: FT_Encoding,
    pub platform_id: FT_UShort,
    pub encoding_id: FT_UShort,
}
#[test]
fn bindgen_test_layout_FT_CharMapRec_() {
    assert_eq!(
        ::std::mem::size_of::<FT_CharMapRec_>(),
        16usize,
        concat!("Size of: ", stringify!(FT_CharMapRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_CharMapRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_CharMapRec_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_CharMapRec_)).face as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_CharMapRec_),
            "::",
            stringify!(face)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_CharMapRec_)).encoding as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_CharMapRec_),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_CharMapRec_)).platform_id as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_CharMapRec_),
            "::",
            stringify!(platform_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_CharMapRec_)).encoding_id as *const _ as usize },
        14usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_CharMapRec_),
            "::",
            stringify!(encoding_id)
        )
    );
}
pub type FT_CharMapRec = FT_CharMapRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Face_InternalRec_ {
    _unused: [u8; 0],
}
pub type FT_Face_Internal = *mut FT_Face_InternalRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_FaceRec_ {
    pub num_faces: FT_Long,
    pub face_index: FT_Long,
    pub face_flags: FT_Long,
    pub style_flags: FT_Long,
    pub num_glyphs: FT_Long,
    pub family_name: *mut FT_String,
    pub style_name: *mut FT_String,
    pub num_fixed_sizes: FT_Int,
    pub available_sizes: *mut FT_Bitmap_Size,
    pub num_charmaps: FT_Int,
    pub charmaps: *mut FT_CharMap,
    pub generic: FT_Generic,
    pub bbox: FT_BBox,
    pub units_per_EM: FT_UShort,
    pub ascender: FT_Short,
    pub descender: FT_Short,
    pub height: FT_Short,
    pub max_advance_width: FT_Short,
    pub max_advance_height: FT_Short,
    pub underline_position: FT_Short,
    pub underline_thickness: FT_Short,
    pub glyph: FT_GlyphSlot,
    pub size: FT_Size,
    pub charmap: FT_CharMap,
    pub driver: FT_Driver,
    pub memory: FT_Memory,
    pub stream: FT_Stream,
    pub sizes_list: FT_ListRec,
    pub autohint: FT_Generic,
    pub extensions: *mut ::std::os::raw::c_void,
    pub internal: FT_Face_Internal,
}
#[test]
fn bindgen_test_layout_FT_FaceRec_() {
    assert_eq!(
        ::std::mem::size_of::<FT_FaceRec_>(),
        216usize,
        concat!("Size of: ", stringify!(FT_FaceRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_FaceRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_FaceRec_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).num_faces as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(num_faces)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).face_index as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(face_index)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).face_flags as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(face_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).style_flags as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(style_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).num_glyphs as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(num_glyphs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).family_name as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(family_name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).style_name as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(style_name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).num_fixed_sizes as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(num_fixed_sizes)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).available_sizes as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(available_sizes)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).num_charmaps as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(num_charmaps)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).charmaps as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(charmaps)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).generic as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(generic)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).bbox as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).units_per_EM as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(units_per_EM)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).ascender as *const _ as usize },
        106usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(ascender)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).descender as *const _ as usize },
        108usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(descender)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).height as *const _ as usize },
        110usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).max_advance_width as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(max_advance_width)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).max_advance_height as *const _ as usize },
        114usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(max_advance_height)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).underline_position as *const _ as usize },
        116usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(underline_position)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).underline_thickness as *const _ as usize },
        118usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(underline_thickness)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).glyph as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(glyph)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).size as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).charmap as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(charmap)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).driver as *const _ as usize },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).memory as *const _ as usize },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).stream as *const _ as usize },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(stream)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).sizes_list as *const _ as usize },
        168usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(sizes_list)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).autohint as *const _ as usize },
        184usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(autohint)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).extensions as *const _ as usize },
        200usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(extensions)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_FaceRec_)).internal as *const _ as usize },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(internal)
        )
    );
}
pub type FT_FaceRec = FT_FaceRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Size_InternalRec_ {
    _unused: [u8; 0],
}
pub type FT_Size_Internal = *mut FT_Size_InternalRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Size_Metrics_ {
    pub x_ppem: FT_UShort,
    pub y_ppem: FT_UShort,
    pub x_scale: FT_Fixed,
    pub y_scale: FT_Fixed,
    pub ascender: FT_Pos,
    pub descender: FT_Pos,
    pub height: FT_Pos,
    pub max_advance: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_Size_Metrics_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Size_Metrics_>(),
        28usize,
        concat!("Size of: ", stringify!(FT_Size_Metrics_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Size_Metrics_>(),
        4usize,
        concat!("Alignment of ", stringify!(FT_Size_Metrics_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Size_Metrics_)).x_ppem as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Size_Metrics_),
            "::",
            stringify!(x_ppem)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Size_Metrics_)).y_ppem as *const _ as usize },
        2usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Size_Metrics_),
            "::",
            stringify!(y_ppem)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Size_Metrics_)).x_scale as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Size_Metrics_),
            "::",
            stringify!(x_scale)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Size_Metrics_)).y_scale as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Size_Metrics_),
            "::",
            stringify!(y_scale)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Size_Metrics_)).ascender as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Size_Metrics_),
            "::",
            stringify!(ascender)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Size_Metrics_)).descender as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Size_Metrics_),
            "::",
            stringify!(descender)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Size_Metrics_)).height as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Size_Metrics_),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Size_Metrics_)).max_advance as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Size_Metrics_),
            "::",
            stringify!(max_advance)
        )
    );
}
pub type FT_Size_Metrics = FT_Size_Metrics_;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_SizeRec_ {
    pub face: FT_Face,
    pub generic: FT_Generic,
    pub metrics: FT_Size_Metrics,
    pub internal: FT_Size_Internal,
}
#[test]
fn bindgen_test_layout_FT_SizeRec_() {
    assert_eq!(
        ::std::mem::size_of::<FT_SizeRec_>(),
        64usize,
        concat!("Size of: ", stringify!(FT_SizeRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_SizeRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_SizeRec_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_SizeRec_)).face as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_SizeRec_),
            "::",
            stringify!(face)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_SizeRec_)).generic as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_SizeRec_),
            "::",
            stringify!(generic)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_SizeRec_)).metrics as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_SizeRec_),
            "::",
            stringify!(metrics)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_SizeRec_)).internal as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_SizeRec_),
            "::",
            stringify!(internal)
        )
    );
}
pub type FT_SizeRec = FT_SizeRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_SubGlyphRec_ {
    _unused: [u8; 0],
}
pub type FT_SubGlyph = *mut FT_SubGlyphRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Slot_InternalRec_ {
    _unused: [u8; 0],
}
pub type FT_Slot_Internal = *mut FT_Slot_InternalRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_GlyphSlotRec_ {
    pub library: FT_Library,
    pub face: FT_Face,
    pub next: FT_GlyphSlot,
    pub reserved: FT_UInt,
    pub generic: FT_Generic,
    pub metrics: FT_Glyph_Metrics,
    pub linearHoriAdvance: FT_Fixed,
    pub linearVertAdvance: FT_Fixed,
    pub advance: FT_Vector,
    pub format: FT_Glyph_Format,
    pub bitmap: FT_Bitmap,
    pub bitmap_left: FT_Int,
    pub bitmap_top: FT_Int,
    pub outline: FT_Outline,
    pub num_subglyphs: FT_UInt,
    pub subglyphs: FT_SubGlyph,
    pub control_data: *mut ::std::os::raw::c_void,
    pub control_len: ::std::os::raw::c_long,
    pub lsb_delta: FT_Pos,
    pub rsb_delta: FT_Pos,
    pub other: *mut ::std::os::raw::c_void,
    pub internal: FT_Slot_Internal,
}
#[test]
fn bindgen_test_layout_FT_GlyphSlotRec_() {
    assert_eq!(
        ::std::mem::size_of::<FT_GlyphSlotRec_>(),
        248usize,
        concat!("Size of: ", stringify!(FT_GlyphSlotRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_GlyphSlotRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_GlyphSlotRec_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).library as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(library)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).face as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(face)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).next as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).reserved as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).generic as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(generic)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).metrics as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(metrics)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).linearHoriAdvance as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(linearHoriAdvance)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).linearVertAdvance as *const _ as usize },
        84usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(linearVertAdvance)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).advance as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(advance)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).format as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).bitmap as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(bitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).bitmap_left as *const _ as usize },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(bitmap_left)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).bitmap_top as *const _ as usize },
        148usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(bitmap_top)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).outline as *const _ as usize },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(outline)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).num_subglyphs as *const _ as usize },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(num_subglyphs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).subglyphs as *const _ as usize },
        200usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(subglyphs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).control_data as *const _ as usize },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(control_data)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).control_len as *const _ as usize },
        216usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(control_len)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).lsb_delta as *const _ as usize },
        220usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(lsb_delta)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).rsb_delta as *const _ as usize },
        224usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(rsb_delta)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).other as *const _ as usize },
        232usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(other)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphSlotRec_)).internal as *const _ as usize },
        240usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(internal)
        )
    );
}
pub type FT_GlyphSlotRec = FT_GlyphSlotRec_;
extern "C" {
    pub fn FT_Init_FreeType(alibrary: *mut FT_Library) -> FT_Error;
}
extern "C" {



    pub fn FT_Done_FreeType(library: FT_Library) -> FT_Error;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Parameter_ {
    pub tag: FT_ULong,
    pub data: FT_Pointer,
}
#[test]
fn bindgen_test_layout_FT_Parameter_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Parameter_>(),
        16usize,
        concat!("Size of: ", stringify!(FT_Parameter_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Parameter_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Parameter_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Parameter_)).tag as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Parameter_),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Parameter_)).data as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Parameter_),
            "::",
            stringify!(data)
        )
    );
}
pub type FT_Parameter = FT_Parameter_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Open_Args_ {
    pub flags: FT_UInt,
    pub memory_base: *const FT_Byte,
    pub memory_size: FT_Long,
    pub pathname: *mut FT_String,
    pub stream: FT_Stream,
    pub driver: FT_Module,
    pub num_params: FT_Int,
    pub params: *mut FT_Parameter,
}
#[test]
fn bindgen_test_layout_FT_Open_Args_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Open_Args_>(),
        64usize,
        concat!("Size of: ", stringify!(FT_Open_Args_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Open_Args_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Open_Args_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Open_Args_)).flags as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Open_Args_),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Open_Args_)).memory_base as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Open_Args_),
            "::",
            stringify!(memory_base)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Open_Args_)).memory_size as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Open_Args_),
            "::",
            stringify!(memory_size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Open_Args_)).pathname as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Open_Args_),
            "::",
            stringify!(pathname)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Open_Args_)).stream as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Open_Args_),
            "::",
            stringify!(stream)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Open_Args_)).driver as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Open_Args_),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Open_Args_)).num_params as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Open_Args_),
            "::",
            stringify!(num_params)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Open_Args_)).params as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Open_Args_),
            "::",
            stringify!(params)
        )
    );
}
pub type FT_Open_Args = FT_Open_Args_;
extern "C" {
    pub fn FT_New_Face(
        library: FT_Library,
        filepathname: *const ::std::os::raw::c_char,
        face_index: FT_Long,
        aface: *mut FT_Face,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_New_Memory_Face(
        library: FT_Library,
        file_base: *const FT_Byte,
        file_size: FT_Long,
        face_index: FT_Long,
        aface: *mut FT_Face,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Open_Face(
        library: FT_Library,
        args: *const FT_Open_Args,
        face_index: FT_Long,
        aface: *mut FT_Face,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Attach_File(face: FT_Face, filepathname: *const ::std::os::raw::c_char) -> FT_Error;
}
extern "C" {
    pub fn FT_Attach_Stream(face: FT_Face, parameters: *mut FT_Open_Args) -> FT_Error;
}
extern "C" {
    pub fn FT_Reference_Face(face: FT_Face) -> FT_Error;
}
extern "C" {
    pub fn FT_Done_Face(face: FT_Face) -> FT_Error;
}
extern "C" {
    pub fn FT_Select_Size(face: FT_Face, strike_index: FT_Int) -> FT_Error;
}
pub const FT_Size_Request_Type__FT_SIZE_REQUEST_TYPE_NOMINAL: FT_Size_Request_Type_ = 0;
pub const FT_Size_Request_Type__FT_SIZE_REQUEST_TYPE_REAL_DIM: FT_Size_Request_Type_ = 1;
pub const FT_Size_Request_Type__FT_SIZE_REQUEST_TYPE_BBOX: FT_Size_Request_Type_ = 2;
pub const FT_Size_Request_Type__FT_SIZE_REQUEST_TYPE_CELL: FT_Size_Request_Type_ = 3;
pub const FT_Size_Request_Type__FT_SIZE_REQUEST_TYPE_SCALES: FT_Size_Request_Type_ = 4;
pub const FT_Size_Request_Type__FT_SIZE_REQUEST_TYPE_MAX: FT_Size_Request_Type_ = 5;
pub type FT_Size_Request_Type_ = ::std::os::raw::c_int;
pub use self::FT_Size_Request_Type_ as FT_Size_Request_Type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Size_RequestRec_ {
    pub type_: FT_Size_Request_Type,
    pub width: FT_Long,
    pub height: FT_Long,
    pub horiResolution: FT_UInt,
    pub vertResolution: FT_UInt,
}
#[test]
fn bindgen_test_layout_FT_Size_RequestRec_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Size_RequestRec_>(),
        20usize,
        concat!("Size of: ", stringify!(FT_Size_RequestRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Size_RequestRec_>(),
        4usize,
        concat!("Alignment of ", stringify!(FT_Size_RequestRec_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Size_RequestRec_)).type_ as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Size_RequestRec_),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Size_RequestRec_)).width as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Size_RequestRec_),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Size_RequestRec_)).height as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Size_RequestRec_),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Size_RequestRec_)).horiResolution as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Size_RequestRec_),
            "::",
            stringify!(horiResolution)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Size_RequestRec_)).vertResolution as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Size_RequestRec_),
            "::",
            stringify!(vertResolution)
        )
    );
}
pub type FT_Size_RequestRec = FT_Size_RequestRec_;

pub type FT_Size_Request = *mut FT_Size_RequestRec_;
extern "C" {
    pub fn FT_Request_Size(face: FT_Face, req: FT_Size_Request) -> FT_Error;
}
extern "C" {
    pub fn FT_Set_Char_Size(
        face: FT_Face,
        char_width: FT_F26Dot6,
        char_height: FT_F26Dot6,
        horz_resolution: FT_UInt,
        vert_resolution: FT_UInt,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Set_Pixel_Sizes(
        face: FT_Face,
        pixel_width: FT_UInt,
        pixel_height: FT_UInt,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Load_Glyph(face: FT_Face, glyph_index: FT_UInt, load_flags: FT_Int32) -> FT_Error;
}
extern "C" {
    pub fn FT_Load_Char(face: FT_Face, char_code: FT_ULong, load_flags: FT_Int32) -> FT_Error;
}
extern "C" {
    pub fn FT_Set_Transform(face: FT_Face, matrix: *mut FT_Matrix, delta: *mut FT_Vector);
}
pub const FT_Render_Mode__FT_RENDER_MODE_NORMAL: FT_Render_Mode_ = 0;
pub const FT_Render_Mode__FT_RENDER_MODE_LIGHT: FT_Render_Mode_ = 1;
pub const FT_Render_Mode__FT_RENDER_MODE_MONO: FT_Render_Mode_ = 2;
pub const FT_Render_Mode__FT_RENDER_MODE_LCD: FT_Render_Mode_ = 3;
pub const FT_Render_Mode__FT_RENDER_MODE_LCD_V: FT_Render_Mode_ = 4;
pub const FT_Render_Mode__FT_RENDER_MODE_MAX: FT_Render_Mode_ = 5;
pub type FT_Render_Mode_ = ::std::os::raw::c_int;
pub use self::FT_Render_Mode_ as FT_Render_Mode;
extern "C" {
    pub fn FT_Render_Glyph(slot: FT_GlyphSlot, render_mode: FT_Render_Mode) -> FT_Error;
}
pub const FT_Kerning_Mode__FT_KERNING_DEFAULT: FT_Kerning_Mode_ = 0;
pub const FT_Kerning_Mode__FT_KERNING_UNFITTED: FT_Kerning_Mode_ = 1;
pub const FT_Kerning_Mode__FT_KERNING_UNSCALED: FT_Kerning_Mode_ = 2;
pub type FT_Kerning_Mode_ = ::std::os::raw::c_int;
pub use self::FT_Kerning_Mode_ as FT_Kerning_Mode;
extern "C" {
    pub fn FT_Get_Kerning(
        face: FT_Face,
        left_glyph: FT_UInt,
        right_glyph: FT_UInt,
        kern_mode: FT_UInt,
        akerning: *mut FT_Vector,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Get_Track_Kerning(
        face: FT_Face,
        point_size: FT_Fixed,
        degree: FT_Int,
        akerning: *mut FT_Fixed,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Get_Glyph_Name(
        face: FT_Face,
        glyph_index: FT_UInt,
        buffer: FT_Pointer,
        buffer_max: FT_UInt,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Get_Postscript_Name(face: FT_Face) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn FT_Select_Charmap(face: FT_Face, encoding: FT_Encoding) -> FT_Error;
}
extern "C" {



    pub fn FT_Set_Charmap(face: FT_Face, charmap: FT_CharMap) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Get_Charmap_Index
    ///
    /// @description:
    /// Retrieve index of a given charmap.
    ///
    /// @input:
    /// charmap ::
    /// A handle to a charmap.
    ///
    /// @return:
    /// The index into the array of character maps within the face to which
    /// `charmap' belongs.  If an error occurs, -1 is returned.
    ///
    pub fn FT_Get_Charmap_Index(charmap: FT_CharMap) -> FT_Int;
}
extern "C" {



    pub fn FT_Get_Char_Index(face: FT_Face, charcode: FT_ULong) -> FT_UInt;
}
extern "C" {
    pub fn FT_Get_First_Char(face: FT_Face, agindex: *mut FT_UInt) -> FT_ULong;
}
extern "C" {
    pub fn FT_Get_Next_Char(face: FT_Face, char_code: FT_ULong, agindex: *mut FT_UInt) -> FT_ULong;
}
extern "C" {

    /// @function:
    /// FT_Face_Properties
    ///
    /// @description:
    /// Set or override certain (library or module-wide) properties on a
    /// face-by-face basis.  Useful for finer-grained control and avoiding
    /// locks on shared structures (threads can modify their own faces as
    /// they see fit).
    ///
    /// Contrary to @FT_Property_Set, this function uses @FT_Parameter so
    /// that you can pass multiple properties to the target face in one call.
    /// Note that only a subset of the available properties can be
    /// controlled.
    ///
    /// * Stem darkening (@FT_PARAM_TAG_STEM_DARKENING, corresponding to the
    /// property `no-stem-darkening' provided by the `autofit' and `cff'
    /// modules; see @no-stem-darkening[autofit] and
    /// @no-stem-darkening[cff]).
    ///
    /// * LCD filter weights (@FT_PARAM_TAG_LCD_FILTER_WEIGHTS, corresponding
    /// to function @FT_Library_SetLcdFilterWeights).
    ///
    /// * Seed value for the CFF `random' operator
    /// (@FT_PARAM_TAG_RANDOM_SEED, corresponding to the `random-seed'
    /// property provided by the `cff' module; see @random-seed).
    ///
    /// Pass NULL as `data' in @FT_Parameter for a given tag to reset the
    /// option and use the library or module default again.
    ///
    /// @input:
    /// face ::
    /// A handle to the source face object.
    ///
    /// num_properties ::
    /// The number of properties that follow.
    ///
    /// properties ::
    /// A handle to an @FT_Parameter array with `num_properties' elements.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// Here an example that sets three properties.  You must define
    /// FT_CONFIG_OPTION_SUBPIXEL_RENDERING to make the LCD filter examples
    /// work.
    ///
    /// {
    /// FT_Parameter         property1;
    /// FT_Bool              darken_stems = 1;
    ///
    /// FT_Parameter         property2;
    /// FT_LcdFiveTapFilter  custom_weight =
    /// { 0x11, 0x44, 0x56, 0x44, 0x11 };
    ///
    /// FT_Parameter         property3;
    /// FT_Int32             random_seed = 314159265;
    ///
    /// FT_Parameter         properties[3] = { property1,
    /// property2,
    /// property3 };
    ///
    ///
    /// property1.tag  = FT_PARAM_TAG_STEM_DARKENING;
    /// property1.data = &darken_stems;
    ///
    /// property2.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;
    /// property2.data = custom_weight;
    ///
    /// property3.tag  = FT_PARAM_TAG_RANDOM_SEED;
    /// property3.data = &random_seed;
    ///
    /// FT_Face_Properties( face, 3, properties );
    /// }
    ///
    /// The next example resets a single property to its default value.
    ///
    /// {
    /// FT_Parameter  property;
    ///
    ///
    /// property.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;
    /// property.data = NULL;
    ///
    /// FT_Face_Properties( face, 1, &property );
    /// }
    ///
    /// @since:
    /// 2.8
    ///
    pub fn FT_Face_Properties(
        face: FT_Face,
        num_properties: FT_UInt,
        properties: *mut FT_Parameter,
    ) -> FT_Error;
}
extern "C" {



    pub fn FT_Get_Name_Index(face: FT_Face, glyph_name: *mut FT_String) -> FT_UInt;
}
extern "C" {

    /// @func:
    /// FT_Get_SubGlyph_Info
    ///
    /// @description:
    /// Retrieve a description of a given subglyph.  Only use it if
    /// `glyph->format' is @FT_GLYPH_FORMAT_COMPOSITE; an error is
    /// returned otherwise.
    ///
    /// @input:
    /// glyph ::
    /// The source glyph slot.
    ///
    /// sub_index ::
    /// The index of the subglyph.  Must be less than
    /// `glyph->num_subglyphs'.
    ///
    /// @output:
    /// p_index ::
    /// The glyph index of the subglyph.
    ///
    /// p_flags ::
    /// The subglyph flags, see @FT_SUBGLYPH_FLAG_XXX.
    ///
    /// p_arg1 ::
    /// The subglyph's first argument (if any).
    ///
    /// p_arg2 ::
    /// The subglyph's second argument (if any).
    ///
    /// p_transform ::
    /// The subglyph transformation (if any).
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// The values of `*p_arg1', `*p_arg2', and `*p_transform' must be
    /// interpreted depending on the flags returned in `*p_flags'.  See the
    /// OpenType specification for details.
    ///
    pub fn FT_Get_SubGlyph_Info(
        glyph: FT_GlyphSlot,
        sub_index: FT_UInt,
        p_index: *mut FT_Int,
        p_flags: *mut FT_UInt,
        p_arg1: *mut FT_Int,
        p_arg2: *mut FT_Int,
        p_transform: *mut FT_Matrix,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Get_FSType_Flags(face: FT_Face) -> FT_UShort;
}
extern "C" {



    pub fn FT_Face_GetCharVariantIndex(
        face: FT_Face,
        charcode: FT_ULong,
        variantSelector: FT_ULong,
    ) -> FT_UInt;
}
extern "C" {



    pub fn FT_Face_GetCharVariantIsDefault(
        face: FT_Face,
        charcode: FT_ULong,
        variantSelector: FT_ULong,
    ) -> FT_Int;
}
extern "C" {
    pub fn FT_Face_GetVariantSelectors(face: FT_Face) -> *mut FT_UInt32;
}
extern "C" {
    pub fn FT_Face_GetVariantsOfChar(face: FT_Face, charcode: FT_ULong) -> *mut FT_UInt32;
}
extern "C" {
    pub fn FT_Face_GetCharsOfVariant(face: FT_Face, variantSelector: FT_ULong) -> *mut FT_UInt32;
}
extern "C" {
    pub fn FT_MulDiv(a: FT_Long, b: FT_Long, c: FT_Long) -> FT_Long;
}
extern "C" {
    pub fn FT_MulFix(a: FT_Long, b: FT_Long) -> FT_Long;
}
extern "C" {



    pub fn FT_DivFix(a: FT_Long, b: FT_Long) -> FT_Long;
}
extern "C" {



    pub fn FT_RoundFix(a: FT_Fixed) -> FT_Fixed;
}
extern "C" {



    pub fn FT_CeilFix(a: FT_Fixed) -> FT_Fixed;
}
extern "C" {



    pub fn FT_FloorFix(a: FT_Fixed) -> FT_Fixed;
}
extern "C" {



    pub fn FT_Vector_Transform(vec: *mut FT_Vector, matrix: *const FT_Matrix);
}
extern "C" {
    pub fn FT_Library_Version(
        library: FT_Library,
        amajor: *mut FT_Int,
        aminor: *mut FT_Int,
        apatch: *mut FT_Int,
    );
}
extern "C" {



    pub fn FT_Face_CheckTrueTypePatents(face: FT_Face) -> FT_Bool;
}
extern "C" {



    pub fn FT_Face_SetUnpatentedHinting(face: FT_Face, value: FT_Bool) -> FT_Bool;
}
extern "C" {
    pub fn FT_Get_Advance(
        face: FT_Face,
        gindex: FT_UInt,
        load_flags: FT_Int32,
        padvance: *mut FT_Fixed,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Get_Advances(
        face: FT_Face,
        start: FT_UInt,
        count: FT_UInt,
        load_flags: FT_Int32,
        padvances: *mut FT_Fixed,
    ) -> FT_Error;
}
/// @struct:
/// FT_Prop_GlyphToScriptMap
///
/// @description:
/// *Experimental* *only*
///
/// The data exchange structure for the @glyph-to-script-map property.
///
/// @since:
/// 2.4.11
///
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Prop_GlyphToScriptMap_ {
    pub face: FT_Face,
    pub map: *mut FT_UShort,
}
#[test]
fn bindgen_test_layout_FT_Prop_GlyphToScriptMap_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Prop_GlyphToScriptMap_>(),
        16usize,
        concat!("Size of: ", stringify!(FT_Prop_GlyphToScriptMap_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Prop_GlyphToScriptMap_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Prop_GlyphToScriptMap_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Prop_GlyphToScriptMap_)).face as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Prop_GlyphToScriptMap_),
            "::",
            stringify!(face)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Prop_GlyphToScriptMap_)).map as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Prop_GlyphToScriptMap_),
            "::",
            stringify!(map)
        )
    );
}
pub type FT_Prop_GlyphToScriptMap = FT_Prop_GlyphToScriptMap_;
/// @struct:
/// FT_Prop_IncreaseXHeight
///
/// @description:
/// The data exchange structure for the @increase-x-height property.
///
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Prop_IncreaseXHeight_ {
    pub face: FT_Face,
    pub limit: FT_UInt,
}
#[test]
fn bindgen_test_layout_FT_Prop_IncreaseXHeight_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Prop_IncreaseXHeight_>(),
        16usize,
        concat!("Size of: ", stringify!(FT_Prop_IncreaseXHeight_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Prop_IncreaseXHeight_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Prop_IncreaseXHeight_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Prop_IncreaseXHeight_)).face as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Prop_IncreaseXHeight_),
            "::",
            stringify!(face)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Prop_IncreaseXHeight_)).limit as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Prop_IncreaseXHeight_),
            "::",
            stringify!(limit)
        )
    );
}
pub type FT_Prop_IncreaseXHeight = FT_Prop_IncreaseXHeight_;
extern "C" {
    pub fn FT_Outline_Get_BBox(outline: *mut FT_Outline, abbox: *mut FT_BBox) -> FT_Error;
}
pub const BDF_PropertyType__BDF_PROPERTY_TYPE_NONE: BDF_PropertyType_ = 0;
pub const BDF_PropertyType__BDF_PROPERTY_TYPE_ATOM: BDF_PropertyType_ = 1;
pub const BDF_PropertyType__BDF_PROPERTY_TYPE_INTEGER: BDF_PropertyType_ = 2;
pub const BDF_PropertyType__BDF_PROPERTY_TYPE_CARDINAL: BDF_PropertyType_ = 3;
pub type BDF_PropertyType_ = ::std::os::raw::c_int;
pub use self::BDF_PropertyType_ as BDF_PropertyType;
/// @struct:
/// BDF_PropertyRec
///
/// @description:
/// This structure models a given BDF/PCF property.
///
/// @fields:
/// type ::
/// The property type.
///
/// u.atom ::
/// The atom string, if type is @BDF_PROPERTY_TYPE_ATOM.  May be
/// NULL, indicating an empty string.
///
/// u.integer ::
/// A signed integer, if type is @BDF_PROPERTY_TYPE_INTEGER.
///
/// u.cardinal ::
/// An unsigned integer, if type is @BDF_PROPERTY_TYPE_CARDINAL.
#[repr(C)]
pub struct BDF_PropertyRec_ {
    pub type_: BDF_PropertyType,
    pub u: BDF_PropertyRec___bindgen_ty_1,
}
#[repr(C)]
pub union BDF_PropertyRec___bindgen_ty_1 {
    pub atom: *const ::std::os::raw::c_char,
    pub integer: FT_Int32,
    pub cardinal: FT_UInt32,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_BDF_PropertyRec___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<BDF_PropertyRec___bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(BDF_PropertyRec___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<BDF_PropertyRec___bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(BDF_PropertyRec___bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(0 as *const BDF_PropertyRec___bindgen_ty_1)).atom as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(BDF_PropertyRec___bindgen_ty_1),
            "::",
            stringify!(atom)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const BDF_PropertyRec___bindgen_ty_1)).integer as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(BDF_PropertyRec___bindgen_ty_1),
            "::",
            stringify!(integer)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const BDF_PropertyRec___bindgen_ty_1)).cardinal as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(BDF_PropertyRec___bindgen_ty_1),
            "::",
            stringify!(cardinal)
        )
    );
}
#[test]
fn bindgen_test_layout_BDF_PropertyRec_() {
    assert_eq!(
        ::std::mem::size_of::<BDF_PropertyRec_>(),
        16usize,
        concat!("Size of: ", stringify!(BDF_PropertyRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<BDF_PropertyRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(BDF_PropertyRec_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const BDF_PropertyRec_)).type_ as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(BDF_PropertyRec_),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const BDF_PropertyRec_)).u as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(BDF_PropertyRec_),
            "::",
            stringify!(u)
        )
    );
}
pub type BDF_PropertyRec = BDF_PropertyRec_;
extern "C" {

    /// @function:
    /// FT_Get_BDF_Charset_ID
    ///
    /// @description:
    /// Retrieve a BDF font character set identity, according to
    /// the BDF specification.
    ///
    /// @input:
    /// face ::
    /// A handle to the input face.
    ///
    /// @output:
    /// acharset_encoding ::
    /// Charset encoding, as a C~string, owned by the face.
    ///
    /// acharset_registry ::
    /// Charset registry, as a C~string, owned by the face.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// This function only works with BDF faces, returning an error otherwise.
    pub fn FT_Get_BDF_Charset_ID(
        face: FT_Face,
        acharset_encoding: *mut *const ::std::os::raw::c_char,
        acharset_registry: *mut *const ::std::os::raw::c_char,
    ) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Get_BDF_Property
    ///
    /// @description:
    /// Retrieve a BDF property from a BDF or PCF font file.
    ///
    /// @input:
    /// face :: A handle to the input face.
    ///
    /// name :: The property name.
    ///
    /// @output:
    /// aproperty :: The property.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// This function works with BDF _and_ PCF fonts.  It returns an error
    /// otherwise.  It also returns an error if the property is not in the
    /// font.
    ///
    /// A `property' is a either key-value pair within the STARTPROPERTIES
    /// ... ENDPROPERTIES block of a BDF font or a key-value pair from the
    /// `info->props' array within a `FontRec' structure of a PCF font.
    ///
    /// Integer properties are always stored as `signed' within PCF fonts;
    /// consequently, @BDF_PROPERTY_TYPE_CARDINAL is a possible return value
    /// for BDF fonts only.
    ///
    /// In case of error, `aproperty->type' is always set to
    /// @BDF_PROPERTY_TYPE_NONE.
    pub fn FT_Get_BDF_Property(
        face: FT_Face,
        prop_name: *const ::std::os::raw::c_char,
        aproperty: *mut BDF_PropertyRec,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Bitmap_Init(abitmap: *mut FT_Bitmap);
}
extern "C" {
    pub fn FT_Bitmap_New(abitmap: *mut FT_Bitmap);
}
extern "C" {



    pub fn FT_Bitmap_Copy(
        library: FT_Library,
        source: *const FT_Bitmap,
        target: *mut FT_Bitmap,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Bitmap_Embolden(
        library: FT_Library,
        bitmap: *mut FT_Bitmap,
        xStrength: FT_Pos,
        yStrength: FT_Pos,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Bitmap_Convert(
        library: FT_Library,
        source: *const FT_Bitmap,
        target: *mut FT_Bitmap,
        alignment: FT_Int,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_GlyphSlot_Own_Bitmap(slot: FT_GlyphSlot) -> FT_Error;
}
extern "C" {
    pub fn FT_Bitmap_Done(library: FT_Library, bitmap: *mut FT_Bitmap) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Stream_OpenBzip2
    ///
    /// @description:
    /// Open a new stream to parse bzip2-compressed font files.  This is
    /// mainly used to support the compressed `*.pcf.bz2' fonts that come
    /// with XFree86.
    ///
    /// @input:
    /// stream ::
    /// The target embedding stream.
    ///
    /// source ::
    /// The source stream.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// The source stream must be opened _before_ calling this function.
    ///
    /// Calling the internal function `FT_Stream_Close' on the new stream will
    /// *not* call `FT_Stream_Close' on the source stream.  None of the stream
    /// objects will be released to the heap.
    ///
    /// The stream implementation is very basic and resets the decompression
    /// process each time seeking backwards is needed within the stream.
    ///
    /// In certain builds of the library, bzip2 compression recognition is
    /// automatically handled when calling @FT_New_Face or @FT_Open_Face.
    /// This means that if no font driver is capable of handling the raw
    /// compressed file, the library will try to open a bzip2 compressed stream
    /// from it and re-open the face with it.
    ///
    /// This function may return `FT_Err_Unimplemented_Feature' if your build
    /// of FreeType was not compiled with bzip2 support.
    pub fn FT_Stream_OpenBzip2(stream: FT_Stream, source: FT_Stream) -> FT_Error;
}

pub type FT_Glyph_Class = FT_Glyph_Class_;
pub type FT_Glyph = *mut FT_GlyphRec_;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_GlyphRec_ {
    pub library: FT_Library,
    pub clazz: *const FT_Glyph_Class,
    pub format: FT_Glyph_Format,
    pub advance: FT_Vector,
}
#[test]
fn bindgen_test_layout_FT_GlyphRec_() {
    assert_eq!(
        ::std::mem::size_of::<FT_GlyphRec_>(),
        32usize,
        concat!("Size of: ", stringify!(FT_GlyphRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_GlyphRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_GlyphRec_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphRec_)).library as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphRec_),
            "::",
            stringify!(library)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphRec_)).clazz as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphRec_),
            "::",
            stringify!(clazz)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphRec_)).format as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphRec_),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_GlyphRec_)).advance as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_GlyphRec_),
            "::",
            stringify!(advance)
        )
    );
}
pub type FT_GlyphRec = FT_GlyphRec_;
pub type FT_BitmapGlyph = *mut FT_BitmapGlyphRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_BitmapGlyphRec_ {
    pub root: FT_GlyphRec,
    pub left: FT_Int,
    pub top: FT_Int,
    pub bitmap: FT_Bitmap,
}
#[test]
fn bindgen_test_layout_FT_BitmapGlyphRec_() {
    assert_eq!(
        ::std::mem::size_of::<FT_BitmapGlyphRec_>(),
        80usize,
        concat!("Size of: ", stringify!(FT_BitmapGlyphRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_BitmapGlyphRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_BitmapGlyphRec_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_BitmapGlyphRec_)).root as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_BitmapGlyphRec_),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_BitmapGlyphRec_)).left as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_BitmapGlyphRec_),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_BitmapGlyphRec_)).top as *const _ as usize },
        36usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_BitmapGlyphRec_),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_BitmapGlyphRec_)).bitmap as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_BitmapGlyphRec_),
            "::",
            stringify!(bitmap)
        )
    );
}
pub type FT_BitmapGlyphRec = FT_BitmapGlyphRec_;
pub type FT_OutlineGlyph = *mut FT_OutlineGlyphRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_OutlineGlyphRec_ {
    pub root: FT_GlyphRec,
    pub outline: FT_Outline,
}
#[test]
fn bindgen_test_layout_FT_OutlineGlyphRec_() {
    assert_eq!(
        ::std::mem::size_of::<FT_OutlineGlyphRec_>(),
        72usize,
        concat!("Size of: ", stringify!(FT_OutlineGlyphRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_OutlineGlyphRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_OutlineGlyphRec_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_OutlineGlyphRec_)).root as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_OutlineGlyphRec_),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_OutlineGlyphRec_)).outline as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_OutlineGlyphRec_),
            "::",
            stringify!(outline)
        )
    );
}
pub type FT_OutlineGlyphRec = FT_OutlineGlyphRec_;
extern "C" {
    pub fn FT_Get_Glyph(slot: FT_GlyphSlot, aglyph: *mut FT_Glyph) -> FT_Error;
}
extern "C" {
    pub fn FT_Glyph_Copy(source: FT_Glyph, target: *mut FT_Glyph) -> FT_Error;
}
extern "C" {



    pub fn FT_Glyph_Transform(
        glyph: FT_Glyph,
        matrix: *mut FT_Matrix,
        delta: *mut FT_Vector,
    ) -> FT_Error;
}
pub const FT_Glyph_BBox_Mode__FT_GLYPH_BBOX_UNSCALED: FT_Glyph_BBox_Mode_ = 0;
pub const FT_Glyph_BBox_Mode__FT_GLYPH_BBOX_SUBPIXELS: FT_Glyph_BBox_Mode_ = 0;
pub const FT_Glyph_BBox_Mode__FT_GLYPH_BBOX_GRIDFIT: FT_Glyph_BBox_Mode_ = 1;
pub const FT_Glyph_BBox_Mode__FT_GLYPH_BBOX_TRUNCATE: FT_Glyph_BBox_Mode_ = 2;
pub const FT_Glyph_BBox_Mode__FT_GLYPH_BBOX_PIXELS: FT_Glyph_BBox_Mode_ = 3;
pub type FT_Glyph_BBox_Mode_ = ::std::os::raw::c_int;
pub use self::FT_Glyph_BBox_Mode_ as FT_Glyph_BBox_Mode;
extern "C" {
    pub fn FT_Glyph_Get_CBox(glyph: FT_Glyph, bbox_mode: FT_UInt, acbox: *mut FT_BBox);
}
extern "C" {
    pub fn FT_Glyph_To_Bitmap(
        the_glyph: *mut FT_Glyph,
        render_mode: FT_Render_Mode,
        origin: *mut FT_Vector,
        destroy: FT_Bool,
    ) -> FT_Error;
}
extern "C" {



    pub fn FT_Done_Glyph(glyph: FT_Glyph);
}
extern "C" {



    pub fn FT_Matrix_Multiply(a: *const FT_Matrix, b: *mut FT_Matrix);
}
extern "C" {



    pub fn FT_Matrix_Invert(matrix: *mut FT_Matrix) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Get_CID_Registry_Ordering_Supplement
    ///
    /// @description:
    /// Retrieve the Registry/Ordering/Supplement triple (also known as the
    /// "R/O/S") from a CID-keyed font.
    ///
    /// @input:
    /// face ::
    /// A handle to the input face.
    ///
    /// @output:
    /// registry ::
    /// The registry, as a C~string, owned by the face.
    ///
    /// ordering ::
    /// The ordering, as a C~string, owned by the face.
    ///
    /// supplement ::
    /// The supplement.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// This function only works with CID faces, returning an error
    /// otherwise.
    ///
    /// @since:
    /// 2.3.6
    pub fn FT_Get_CID_Registry_Ordering_Supplement(
        face: FT_Face,
        registry: *mut *const ::std::os::raw::c_char,
        ordering: *mut *const ::std::os::raw::c_char,
        supplement: *mut FT_Int,
    ) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Get_CID_Is_Internally_CID_Keyed
    ///
    /// @description:
    /// Retrieve the type of the input face, CID keyed or not.  In
    /// contrast to the @FT_IS_CID_KEYED macro this function returns
    /// successfully also for CID-keyed fonts in an SFNT wrapper.
    ///
    /// @input:
    /// face ::
    /// A handle to the input face.
    ///
    /// @output:
    /// is_cid ::
    /// The type of the face as an @FT_Bool.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// This function only works with CID faces and OpenType fonts,
    /// returning an error otherwise.
    ///
    /// @since:
    /// 2.3.9
    pub fn FT_Get_CID_Is_Internally_CID_Keyed(face: FT_Face, is_cid: *mut FT_Bool) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Get_CID_From_Glyph_Index
    ///
    /// @description:
    /// Retrieve the CID of the input glyph index.
    ///
    /// @input:
    /// face ::
    /// A handle to the input face.
    ///
    /// glyph_index ::
    /// The input glyph index.
    ///
    /// @output:
    /// cid ::
    /// The CID as an @FT_UInt.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// This function only works with CID faces and OpenType fonts,
    /// returning an error otherwise.
    ///
    /// @since:
    /// 2.3.9
    pub fn FT_Get_CID_From_Glyph_Index(
        face: FT_Face,
        glyph_index: FT_UInt,
        cid: *mut FT_UInt,
    ) -> FT_Error;
}
extern "C" {



    pub fn FT_Get_Font_Format(face: FT_Face) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn FT_Get_X11_Font_Format(face: FT_Face) -> *const ::std::os::raw::c_char;
}
extern "C" {

    /// @func:
    /// FT_Get_Gasp
    ///
    /// @description:
    /// For a TrueType or OpenType font file, return the rasterizer behaviour
    /// flags from the font's `gasp' table corresponding to a given
    /// character pixel size.
    ///
    /// @input:
    /// face :: The source face handle.
    ///
    /// ppem :: The vertical character pixel size.
    ///
    /// @return:
    /// Bit flags (see @FT_GASP_XXX), or @FT_GASP_NO_TABLE if there is no
    /// `gasp' table in the face.
    ///
    /// @note:
    /// If you want to use the MM functionality of OpenType variation fonts
    /// (i.e., using @FT_Set_Var_Design_Coordinates and friends), call this
    /// function *after* setting an instance since the return values can
    /// change.
    ///
    /// @since:
    /// 2.3.0
    pub fn FT_Get_Gasp(face: FT_Face, ppem: FT_UInt) -> FT_Int;
}
extern "C" {

    /// @function:
    /// FT_TrueTypeGX_Validate
    ///
    /// @description:
    /// Validate various TrueTypeGX tables to assure that all offsets and
    /// indices are valid.  The idea is that a higher-level library that
    /// actually does the text layout can access those tables without
    /// error checking (which can be quite time consuming).
    ///
    /// @input:
    /// face ::
    /// A handle to the input face.
    ///
    /// validation_flags ::
    /// A bit field that specifies the tables to be validated.  See
    /// @FT_VALIDATE_GXXXX for possible values.
    ///
    /// table_length ::
    /// The size of the `tables' array.  Normally, @FT_VALIDATE_GX_LENGTH
    /// should be passed.
    ///
    /// @output:
    /// tables ::
    /// The array where all validated sfnt tables are stored.
    /// The array itself must be allocated by a client.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// This function only works with TrueTypeGX fonts, returning an error
    /// otherwise.
    ///
    /// After use, the application should deallocate the buffers pointed to by
    /// each `tables' element, by calling @FT_TrueTypeGX_Free.  A NULL value
    /// indicates that the table either doesn't exist in the font, the
    /// application hasn't asked for validation, or the validator doesn't have
    /// the ability to validate the sfnt table.
    pub fn FT_TrueTypeGX_Validate(
        face: FT_Face,
        validation_flags: FT_UInt,
        tables: *mut FT_Bytes,
        table_length: FT_UInt,
    ) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_TrueTypeGX_Free
    ///
    /// @description:
    /// Free the buffer allocated by TrueTypeGX validator.
    ///
    /// @input:
    /// face ::
    /// A handle to the input face.
    ///
    /// table ::
    /// The pointer to the buffer allocated by
    /// @FT_TrueTypeGX_Validate.
    ///
    /// @note:
    /// This function must be used to free the buffer allocated by
    /// @FT_TrueTypeGX_Validate only.
    pub fn FT_TrueTypeGX_Free(face: FT_Face, table: FT_Bytes);
}
extern "C" {

    /// @function:
    /// FT_ClassicKern_Validate
    ///
    /// @description:
    /// Validate classic (16-bit format) kern table to assure that the offsets
    /// and indices are valid.  The idea is that a higher-level library that
    /// actually does the text layout can access those tables without error
    /// checking (which can be quite time consuming).
    ///
    /// The `kern' table validator in @FT_TrueTypeGX_Validate deals with both
    /// the new 32-bit format and the classic 16-bit format, while
    /// FT_ClassicKern_Validate only supports the classic 16-bit format.
    ///
    /// @input:
    /// face ::
    /// A handle to the input face.
    ///
    /// validation_flags ::
    /// A bit field that specifies the dialect to be validated.  See
    /// @FT_VALIDATE_CKERNXXX for possible values.
    ///
    /// @output:
    /// ckern_table ::
    /// A pointer to the kern table.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// After use, the application should deallocate the buffers pointed to by
    /// `ckern_table', by calling @FT_ClassicKern_Free.  A NULL value
    /// indicates that the table doesn't exist in the font.
    pub fn FT_ClassicKern_Validate(
        face: FT_Face,
        validation_flags: FT_UInt,
        ckern_table: *mut FT_Bytes,
    ) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_ClassicKern_Free
    ///
    /// @description:
    /// Free the buffer allocated by classic Kern validator.
    ///
    /// @input:
    /// face ::
    /// A handle to the input face.
    ///
    /// table ::
    /// The pointer to the buffer that is allocated by
    /// @FT_ClassicKern_Validate.
    ///
    /// @note:
    /// This function must be used to free the buffer allocated by
    /// @FT_ClassicKern_Validate only.
    pub fn FT_ClassicKern_Free(face: FT_Face, table: FT_Bytes);
}
extern "C" {

    /// @function:
    /// FT_Stream_OpenGzip
    ///
    /// @description:
    /// Open a new stream to parse gzip-compressed font files.  This is
    /// mainly used to support the compressed `*.pcf.gz' fonts that come
    /// with XFree86.
    ///
    /// @input:
    /// stream ::
    /// The target embedding stream.
    ///
    /// source ::
    /// The source stream.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// The source stream must be opened _before_ calling this function.
    ///
    /// Calling the internal function `FT_Stream_Close' on the new stream will
    /// *not* call `FT_Stream_Close' on the source stream.  None of the stream
    /// objects will be released to the heap.
    ///
    /// The stream implementation is very basic and resets the decompression
    /// process each time seeking backwards is needed within the stream.
    ///
    /// In certain builds of the library, gzip compression recognition is
    /// automatically handled when calling @FT_New_Face or @FT_Open_Face.
    /// This means that if no font driver is capable of handling the raw
    /// compressed file, the library will try to open a gzipped stream from
    /// it and re-open the face with it.
    ///
    /// This function may return `FT_Err_Unimplemented_Feature' if your build
    /// of FreeType was not compiled with zlib support.
    pub fn FT_Stream_OpenGzip(stream: FT_Stream, source: FT_Stream) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Gzip_Uncompress
    ///
    /// @description:
    /// Decompress a zipped input buffer into an output buffer.  This function
    /// is modeled after zlib's `uncompress' function.
    ///
    /// @input:
    /// memory ::
    /// A FreeType memory handle.
    ///
    /// input ::
    /// The input buffer.
    ///
    /// input_len ::
    /// The length of the input buffer.
    ///
    /// @output:
    /// output::
    /// The output buffer.
    ///
    /// @inout:
    /// output_len ::
    /// Before calling the function, this is the total size of the output
    /// buffer, which must be large enough to hold the entire uncompressed
    /// data (so the size of the uncompressed data must be known in
    /// advance).  After calling the function, `output_len' is the size of
    /// the used data in `output'.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// This function may return `FT_Err_Unimplemented_Feature' if your build
    /// of FreeType was not compiled with zlib support.
    ///
    /// @since:
    /// 2.5.1
    pub fn FT_Gzip_Uncompress(
        memory: FT_Memory,
        output: *mut FT_Byte,
        output_len: *mut FT_ULong,
        input: *const FT_Byte,
        input_len: FT_ULong,
    ) -> FT_Error;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_IncrementalRec_ {
    _unused: [u8; 0],
}
/// @type:
/// FT_Incremental
///
/// @description:
/// An opaque type describing a user-provided object used to implement
/// `incremental' glyph loading within FreeType.  This is used to support
/// embedded fonts in certain environments (e.g., PostScript interpreters),
/// where the glyph data isn't in the font file, or must be overridden by
/// different values.
///
/// @note:
/// It is up to client applications to create and implement @FT_Incremental
/// objects, as long as they provide implementations for the methods
/// @FT_Incremental_GetGlyphDataFunc, @FT_Incremental_FreeGlyphDataFunc
/// and @FT_Incremental_GetGlyphMetricsFunc.
///
/// See the description of @FT_Incremental_InterfaceRec to understand how
/// to use incremental objects with FreeType.
///
pub type FT_Incremental = *mut FT_IncrementalRec_;
/// @struct:
/// FT_Incremental_MetricsRec
///
/// @description:
/// A small structure used to contain the basic glyph metrics returned
/// by the @FT_Incremental_GetGlyphMetricsFunc method.
///
/// @fields:
/// bearing_x ::
/// Left bearing, in font units.
///
/// bearing_y ::
/// Top bearing, in font units.
///
/// advance ::
/// Horizontal component of glyph advance, in font units.
///
/// advance_v ::
/// Vertical component of glyph advance, in font units.
///
/// @note:
/// These correspond to horizontal or vertical metrics depending on the
/// value of the `vertical' argument to the function
/// @FT_Incremental_GetGlyphMetricsFunc.
///
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Incremental_MetricsRec_ {
    pub bearing_x: FT_Long,
    pub bearing_y: FT_Long,
    pub advance: FT_Long,
    pub advance_v: FT_Long,
}
#[test]
fn bindgen_test_layout_FT_Incremental_MetricsRec_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Incremental_MetricsRec_>(),
        16usize,
        concat!("Size of: ", stringify!(FT_Incremental_MetricsRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Incremental_MetricsRec_>(),
        4usize,
        concat!("Alignment of ", stringify!(FT_Incremental_MetricsRec_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Incremental_MetricsRec_)).bearing_x as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Incremental_MetricsRec_),
            "::",
            stringify!(bearing_x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Incremental_MetricsRec_)).bearing_y as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Incremental_MetricsRec_),
            "::",
            stringify!(bearing_y)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Incremental_MetricsRec_)).advance as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Incremental_MetricsRec_),
            "::",
            stringify!(advance)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Incremental_MetricsRec_)).advance_v as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Incremental_MetricsRec_),
            "::",
            stringify!(advance_v)
        )
    );
}
pub type FT_Incremental_MetricsRec = FT_Incremental_MetricsRec_;
/// @struct:
/// FT_Incremental_Metrics
///
/// @description:
/// A handle to an @FT_Incremental_MetricsRec structure.
///
pub type FT_Incremental_Metrics = *mut FT_Incremental_MetricsRec_;
/// @type:
/// FT_Incremental_GetGlyphDataFunc
///
/// @description:
/// A function called by FreeType to access a given glyph's data bytes
/// during @FT_Load_Glyph or @FT_Load_Char if incremental loading is
/// enabled.
///
/// Note that the format of the glyph's data bytes depends on the font
/// file format.  For TrueType, it must correspond to the raw bytes within
/// the `glyf' table.  For PostScript formats, it must correspond to the
/// *unencrypted* charstring bytes, without any `lenIV' header.  It is
/// undefined for any other format.
///
/// @input:
/// incremental ::
/// Handle to an opaque @FT_Incremental handle provided by the client
/// application.
///
/// glyph_index ::
/// Index of relevant glyph.
///
/// @output:
/// adata ::
/// A structure describing the returned glyph data bytes (which will be
/// accessed as a read-only byte block).
///
/// @return:
/// FreeType error code.  0~means success.
///
/// @note:
/// If this function returns successfully the method
/// @FT_Incremental_FreeGlyphDataFunc will be called later to release
/// the data bytes.
///
/// Nested calls to @FT_Incremental_GetGlyphDataFunc can happen for
/// compound glyphs.
///
pub type FT_Incremental_GetGlyphDataFunc = ::std::option::Option<
    unsafe extern "C" fn(incremental: FT_Incremental, glyph_index: FT_UInt, adata: *mut FT_Data)
        -> FT_Error,
>;
/// @type:
/// FT_Incremental_FreeGlyphDataFunc
///
/// @description:
/// A function used to release the glyph data bytes returned by a
/// successful call to @FT_Incremental_GetGlyphDataFunc.
///
/// @input:
/// incremental ::
/// A handle to an opaque @FT_Incremental handle provided by the client
/// application.
///
/// data ::
/// A structure describing the glyph data bytes (which will be accessed
/// as a read-only byte block).
///
pub type FT_Incremental_FreeGlyphDataFunc = ::std::option::Option<
    unsafe extern "C" fn(incremental: FT_Incremental, data: *mut FT_Data),
>;
/// @type:
/// FT_Incremental_GetGlyphMetricsFunc
///
/// @description:
/// A function used to retrieve the basic metrics of a given glyph index
/// before accessing its data.  This is necessary because, in certain
/// formats like TrueType, the metrics are stored in a different place from
/// the glyph images proper.
///
/// @input:
/// incremental ::
/// A handle to an opaque @FT_Incremental handle provided by the client
/// application.
///
/// glyph_index ::
/// Index of relevant glyph.
///
/// vertical ::
/// If true, return vertical metrics.
///
/// ametrics ::
/// This parameter is used for both input and output.
/// The original glyph metrics, if any, in font units.  If metrics are
/// not available all the values must be set to zero.
///
/// @output:
/// ametrics ::
/// The replacement glyph metrics in font units.
///
pub type FT_Incremental_GetGlyphMetricsFunc = ::std::option::Option<
    unsafe extern "C" fn(
        incremental: FT_Incremental,
        glyph_index: FT_UInt,
        vertical: FT_Bool,
        ametrics: *mut FT_Incremental_MetricsRec,
    ) -> FT_Error,
>;
/// @struct:
/// FT_Incremental_FuncsRec
///
/// @description:
/// A table of functions for accessing fonts that load data
/// incrementally.  Used in @FT_Incremental_InterfaceRec.
///
/// @fields:
/// get_glyph_data ::
/// The function to get glyph data.  Must not be null.
///
/// free_glyph_data ::
/// The function to release glyph data.  Must not be null.
///
/// get_glyph_metrics ::
/// The function to get glyph metrics.  May be null if the font does
/// not provide overriding glyph metrics.
///
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Incremental_FuncsRec_ {
    pub get_glyph_data: FT_Incremental_GetGlyphDataFunc,
    pub free_glyph_data: FT_Incremental_FreeGlyphDataFunc,
    pub get_glyph_metrics: FT_Incremental_GetGlyphMetricsFunc,
}
#[test]
fn bindgen_test_layout_FT_Incremental_FuncsRec_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Incremental_FuncsRec_>(),
        24usize,
        concat!("Size of: ", stringify!(FT_Incremental_FuncsRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Incremental_FuncsRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Incremental_FuncsRec_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Incremental_FuncsRec_)).get_glyph_data as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Incremental_FuncsRec_),
            "::",
            stringify!(get_glyph_data)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Incremental_FuncsRec_)).free_glyph_data as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Incremental_FuncsRec_),
            "::",
            stringify!(free_glyph_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const FT_Incremental_FuncsRec_)).get_glyph_metrics as *const _ as usize
        },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Incremental_FuncsRec_),
            "::",
            stringify!(get_glyph_metrics)
        )
    );
}
pub type FT_Incremental_FuncsRec = FT_Incremental_FuncsRec_;
/// @struct:
/// FT_Incremental_InterfaceRec
///
/// @description:
/// A structure to be used with @FT_Open_Face to indicate that the user
/// wants to support incremental glyph loading.  You should use it with
/// @FT_PARAM_TAG_INCREMENTAL as in the following example:
///
/// {
/// FT_Incremental_InterfaceRec  inc_int;
/// FT_Parameter                 parameter;
/// FT_Open_Args                 open_args;
///
///
/// // set up incremental descriptor
/// inc_int.funcs  = my_funcs;
/// inc_int.object = my_object;
///
/// // set up optional parameter
/// parameter.tag  = FT_PARAM_TAG_INCREMENTAL;
/// parameter.data = &inc_int;
///
/// // set up FT_Open_Args structure
/// open_args.flags      = FT_OPEN_PATHNAME | FT_OPEN_PARAMS;
/// open_args.pathname   = my_font_pathname;
/// open_args.num_params = 1;
/// open_args.params     = &parameter; // we use one optional argument
///
/// // open the font
/// error = FT_Open_Face( library, &open_args, index, &face );
/// ...
/// }
///
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Incremental_InterfaceRec_ {
    pub funcs: *const FT_Incremental_FuncsRec,
    pub object: FT_Incremental,
}
#[test]
fn bindgen_test_layout_FT_Incremental_InterfaceRec_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Incremental_InterfaceRec_>(),
        16usize,
        concat!("Size of: ", stringify!(FT_Incremental_InterfaceRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Incremental_InterfaceRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Incremental_InterfaceRec_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Incremental_InterfaceRec_)).funcs as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Incremental_InterfaceRec_),
            "::",
            stringify!(funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Incremental_InterfaceRec_)).object as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Incremental_InterfaceRec_),
            "::",
            stringify!(object)
        )
    );
}
pub type FT_Incremental_InterfaceRec = FT_Incremental_InterfaceRec_;
/// @type:
/// FT_Incremental_Interface
///
/// @description:
/// A pointer to an @FT_Incremental_InterfaceRec structure.
///
pub type FT_Incremental_Interface = *mut FT_Incremental_InterfaceRec;
pub const FT_LcdFilter__FT_LCD_FILTER_NONE: FT_LcdFilter_ = 0;
pub const FT_LcdFilter__FT_LCD_FILTER_DEFAULT: FT_LcdFilter_ = 1;
pub const FT_LcdFilter__FT_LCD_FILTER_LIGHT: FT_LcdFilter_ = 2;
pub const FT_LcdFilter__FT_LCD_FILTER_LEGACY1: FT_LcdFilter_ = 3;
pub const FT_LcdFilter__FT_LCD_FILTER_LEGACY: FT_LcdFilter_ = 16;
pub const FT_LcdFilter__FT_LCD_FILTER_MAX: FT_LcdFilter_ = 17;
pub type FT_LcdFilter_ = ::std::os::raw::c_int;
pub use self::FT_LcdFilter_ as FT_LcdFilter;
extern "C" {

    /// @func:
    /// FT_Library_SetLcdFilter
    ///
    /// @description:
    /// This function is used to apply color filtering to LCD decimated
    /// bitmaps, like the ones used when calling @FT_Render_Glyph with
    /// @FT_RENDER_MODE_LCD or @FT_RENDER_MODE_LCD_V.
    ///
    /// @input:
    /// library ::
    /// A handle to the target library instance.
    ///
    /// filter ::
    /// The filter type.
    ///
    /// You can use @FT_LCD_FILTER_NONE here to disable this feature, or
    /// @FT_LCD_FILTER_DEFAULT to use a default filter that should work
    /// well on most LCD screens.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// This feature is always disabled by default.  Clients must make an
    /// explicit call to this function with a `filter' value other than
    /// @FT_LCD_FILTER_NONE in order to enable it.
    ///
    /// Due to *PATENTS* covering subpixel rendering, this function doesn't
    /// do anything except returning `FT_Err_Unimplemented_Feature' if the
    /// configuration macro FT_CONFIG_OPTION_SUBPIXEL_RENDERING is not
    /// defined in your build of the library, which should correspond to all
    /// default builds of FreeType.
    ///
    /// @since:
    /// 2.3.0
    pub fn FT_Library_SetLcdFilter(library: FT_Library, filter: FT_LcdFilter) -> FT_Error;
}
extern "C" {

    /// @func:
    /// FT_Library_SetLcdFilterWeights
    ///
    /// @description:
    /// This function can be used to enable LCD filter with custom weights,
    /// instead of using presets in @FT_Library_SetLcdFilter.
    ///
    /// @input:
    /// library ::
    /// A handle to the target library instance.
    ///
    /// weights ::
    /// A pointer to an array; the function copies the first five bytes and
    /// uses them to specify the filter weights.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// Due to *PATENTS* covering subpixel rendering, this function doesn't
    /// do anything except returning `FT_Err_Unimplemented_Feature' if the
    /// configuration macro FT_CONFIG_OPTION_SUBPIXEL_RENDERING is not
    /// defined in your build of the library, which should correspond to all
    /// default builds of FreeType.
    ///
    /// LCD filter weights can also be set per face using @FT_Face_Properties
    /// with @FT_PARAM_TAG_LCD_FILTER_WEIGHTS.
    ///
    /// @since:
    /// 2.4.0
    pub fn FT_Library_SetLcdFilterWeights(
        library: FT_Library,
        weights: *mut ::std::os::raw::c_uchar,
    ) -> FT_Error;
}
pub type FT_LcdFiveTapFilter = [FT_Byte; 5usize];
extern "C" {



    pub fn FT_List_Find(list: FT_List, data: *mut ::std::os::raw::c_void) -> FT_ListNode;
}
extern "C" {



    pub fn FT_List_Add(list: FT_List, node: FT_ListNode);
}
extern "C" {



    pub fn FT_List_Insert(list: FT_List, node: FT_ListNode);
}
extern "C" {



    pub fn FT_List_Remove(list: FT_List, node: FT_ListNode);
}
extern "C" {



    pub fn FT_List_Up(list: FT_List, node: FT_ListNode);
}
pub type FT_List_Iterator = ::std::option::Option<
    unsafe extern "C" fn(node: FT_ListNode, user: *mut ::std::os::raw::c_void)
        -> FT_Error,
>;
extern "C" {



    pub fn FT_List_Iterate(
        list: FT_List,
        iterator: FT_List_Iterator,
        user: *mut ::std::os::raw::c_void,
    ) -> FT_Error;
}
pub type FT_List_Destructor = ::std::option::Option<
    unsafe extern "C" fn(
        memory: FT_Memory,
        data: *mut ::std::os::raw::c_void,
        user: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn FT_List_Finalize(
        list: FT_List,
        destroy: FT_List_Destructor,
        memory: FT_Memory,
        user: *mut ::std::os::raw::c_void,
    );
}
extern "C" {

    /// @function:
    /// FT_Stream_OpenLZW
    ///
    /// @description:
    /// Open a new stream to parse LZW-compressed font files.  This is
    /// mainly used to support the compressed `*.pcf.Z' fonts that come
    /// with XFree86.
    ///
    /// @input:
    /// stream :: The target embedding stream.
    ///
    /// source :: The source stream.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// The source stream must be opened _before_ calling this function.
    ///
    /// Calling the internal function `FT_Stream_Close' on the new stream will
    /// *not* call `FT_Stream_Close' on the source stream.  None of the stream
    /// objects will be released to the heap.
    ///
    /// The stream implementation is very basic and resets the decompression
    /// process each time seeking backwards is needed within the stream
    ///
    /// In certain builds of the library, LZW compression recognition is
    /// automatically handled when calling @FT_New_Face or @FT_Open_Face.
    /// This means that if no font driver is capable of handling the raw
    /// compressed file, the library will try to open a LZW stream from it
    /// and re-open the face with it.
    ///
    /// This function may return `FT_Err_Unimplemented_Feature' if your build
    /// of FreeType was not compiled with LZW support.
    pub fn FT_Stream_OpenLZW(stream: FT_Stream, source: FT_Stream) -> FT_Error;
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PS_FontInfoRec_ {
    pub version: *mut FT_String,
    pub notice: *mut FT_String,
    pub full_name: *mut FT_String,
    pub family_name: *mut FT_String,
    pub weight: *mut FT_String,
    pub italic_angle: FT_Long,
    pub is_fixed_pitch: FT_Bool,
    pub underline_position: FT_Short,
    pub underline_thickness: FT_UShort,
}
#[test]
fn bindgen_test_layout_PS_FontInfoRec_() {
    assert_eq!(
        ::std::mem::size_of::<PS_FontInfoRec_>(),
        56usize,
        concat!("Size of: ", stringify!(PS_FontInfoRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<PS_FontInfoRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(PS_FontInfoRec_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_FontInfoRec_)).version as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_FontInfoRec_),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_FontInfoRec_)).notice as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_FontInfoRec_),
            "::",
            stringify!(notice)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_FontInfoRec_)).full_name as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_FontInfoRec_),
            "::",
            stringify!(full_name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_FontInfoRec_)).family_name as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_FontInfoRec_),
            "::",
            stringify!(family_name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_FontInfoRec_)).weight as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_FontInfoRec_),
            "::",
            stringify!(weight)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_FontInfoRec_)).italic_angle as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_FontInfoRec_),
            "::",
            stringify!(italic_angle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_FontInfoRec_)).is_fixed_pitch as *const _ as usize },
        44usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_FontInfoRec_),
            "::",
            stringify!(is_fixed_pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_FontInfoRec_)).underline_position as *const _ as usize },
        46usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_FontInfoRec_),
            "::",
            stringify!(underline_position)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_FontInfoRec_)).underline_thickness as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_FontInfoRec_),
            "::",
            stringify!(underline_thickness)
        )
    );
}
pub type PS_FontInfo = *mut PS_FontInfoRec_;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PS_PrivateRec_ {
    pub unique_id: FT_Int,
    pub lenIV: FT_Int,
    pub num_blue_values: FT_Byte,
    pub num_other_blues: FT_Byte,
    pub num_family_blues: FT_Byte,
    pub num_family_other_blues: FT_Byte,
    pub blue_values: [FT_Short; 14usize],
    pub other_blues: [FT_Short; 10usize],
    pub family_blues: [FT_Short; 14usize],
    pub family_other_blues: [FT_Short; 10usize],
    pub blue_scale: FT_Fixed,
    pub blue_shift: FT_Int,
    pub blue_fuzz: FT_Int,
    pub standard_width: [FT_UShort; 1usize],
    pub standard_height: [FT_UShort; 1usize],
    pub num_snap_widths: FT_Byte,
    pub num_snap_heights: FT_Byte,
    pub force_bold: FT_Bool,
    pub round_stem_up: FT_Bool,
    pub snap_widths: [FT_Short; 13usize],
    pub snap_heights: [FT_Short; 13usize],
    pub expansion_factor: FT_Fixed,
    pub language_group: FT_Long,
    pub password: FT_Long,
    pub min_feature: [FT_Short; 2usize],
}
#[test]
fn bindgen_test_layout_PS_PrivateRec_() {
    assert_eq!(
        ::std::mem::size_of::<PS_PrivateRec_>(),
        196usize,
        concat!("Size of: ", stringify!(PS_PrivateRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<PS_PrivateRec_>(),
        4usize,
        concat!("Alignment of ", stringify!(PS_PrivateRec_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).unique_id as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(unique_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).lenIV as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(lenIV)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).num_blue_values as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(num_blue_values)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).num_other_blues as *const _ as usize },
        9usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(num_other_blues)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).num_family_blues as *const _ as usize },
        10usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(num_family_blues)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).num_family_other_blues as *const _ as usize },
        11usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(num_family_other_blues)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).blue_values as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(blue_values)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).other_blues as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(other_blues)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).family_blues as *const _ as usize },
        60usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(family_blues)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).family_other_blues as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(family_other_blues)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).blue_scale as *const _ as usize },
        108usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(blue_scale)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).blue_shift as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(blue_shift)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).blue_fuzz as *const _ as usize },
        116usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(blue_fuzz)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).standard_width as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(standard_width)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).standard_height as *const _ as usize },
        122usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(standard_height)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).num_snap_widths as *const _ as usize },
        124usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(num_snap_widths)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).num_snap_heights as *const _ as usize },
        125usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(num_snap_heights)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).force_bold as *const _ as usize },
        126usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(force_bold)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).round_stem_up as *const _ as usize },
        127usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(round_stem_up)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).snap_widths as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(snap_widths)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).snap_heights as *const _ as usize },
        154usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(snap_heights)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).expansion_factor as *const _ as usize },
        180usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(expansion_factor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).language_group as *const _ as usize },
        184usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(language_group)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).password as *const _ as usize },
        188usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(password)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const PS_PrivateRec_)).min_feature as *const _ as usize },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(PS_PrivateRec_),
            "::",
            stringify!(min_feature)
        )
    );
}
pub type PS_Private = *mut PS_PrivateRec_;
extern "C" {

    /// @function:
    /// FT_Has_PS_Glyph_Names
    ///
    /// @description:
    /// Return true if a given face provides reliable PostScript glyph
    /// names.  This is similar to using the @FT_HAS_GLYPH_NAMES macro,
    /// except that certain fonts (mostly TrueType) contain incorrect
    /// glyph name tables.
    ///
    /// When this function returns true, the caller is sure that the glyph
    /// names returned by @FT_Get_Glyph_Name are reliable.
    ///
    /// @input:
    /// face ::
    /// face handle
    ///
    /// @return:
    /// Boolean.  True if glyph names are reliable.
    ///
    pub fn FT_Has_PS_Glyph_Names(face: FT_Face) -> FT_Int;
}
extern "C" {

    /// @function:
    /// FT_Get_PS_Font_Info
    ///
    /// @description:
    /// Retrieve the @PS_FontInfoRec structure corresponding to a given
    /// PostScript font.
    ///
    /// @input:
    /// face ::
    /// PostScript face handle.
    ///
    /// @output:
    /// afont_info ::
    /// Output font info structure pointer.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// String pointers within the @PS_FontInfoRec structure are owned by
    /// the face and don't need to be freed by the caller.  Missing entries
    /// in the font's FontInfo dictionary are represented by NULL pointers.
    ///
    /// If the font's format is not PostScript-based, this function will
    /// return the `FT_Err_Invalid_Argument' error code.
    ///
    pub fn FT_Get_PS_Font_Info(face: FT_Face, afont_info: PS_FontInfo) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Get_PS_Font_Private
    ///
    /// @description:
    /// Retrieve the @PS_PrivateRec structure corresponding to a given
    /// PostScript font.
    ///
    /// @input:
    /// face ::
    /// PostScript face handle.
    ///
    /// @output:
    /// afont_private ::
    /// Output private dictionary structure pointer.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// The string pointers within the @PS_PrivateRec structure are owned by
    /// the face and don't need to be freed by the caller.
    ///
    /// If the font's format is not PostScript-based, this function returns
    /// the `FT_Err_Invalid_Argument' error code.
    ///
    pub fn FT_Get_PS_Font_Private(face: FT_Face, afont_private: PS_Private) -> FT_Error;
}
pub const PS_Dict_Keys__PS_DICT_FONT_TYPE: PS_Dict_Keys_ = 0;
pub const PS_Dict_Keys__PS_DICT_FONT_MATRIX: PS_Dict_Keys_ = 1;
pub const PS_Dict_Keys__PS_DICT_FONT_BBOX: PS_Dict_Keys_ = 2;
pub const PS_Dict_Keys__PS_DICT_PAINT_TYPE: PS_Dict_Keys_ = 3;
pub const PS_Dict_Keys__PS_DICT_FONT_NAME: PS_Dict_Keys_ = 4;
pub const PS_Dict_Keys__PS_DICT_UNIQUE_ID: PS_Dict_Keys_ = 5;
pub const PS_Dict_Keys__PS_DICT_NUM_CHAR_STRINGS: PS_Dict_Keys_ = 6;
pub const PS_Dict_Keys__PS_DICT_CHAR_STRING_KEY: PS_Dict_Keys_ = 7;
pub const PS_Dict_Keys__PS_DICT_CHAR_STRING: PS_Dict_Keys_ = 8;
pub const PS_Dict_Keys__PS_DICT_ENCODING_TYPE: PS_Dict_Keys_ = 9;
pub const PS_Dict_Keys__PS_DICT_ENCODING_ENTRY: PS_Dict_Keys_ = 10;
pub const PS_Dict_Keys__PS_DICT_NUM_SUBRS: PS_Dict_Keys_ = 11;
pub const PS_Dict_Keys__PS_DICT_SUBR: PS_Dict_Keys_ = 12;
pub const PS_Dict_Keys__PS_DICT_STD_HW: PS_Dict_Keys_ = 13;
pub const PS_Dict_Keys__PS_DICT_STD_VW: PS_Dict_Keys_ = 14;
pub const PS_Dict_Keys__PS_DICT_NUM_BLUE_VALUES: PS_Dict_Keys_ = 15;
pub const PS_Dict_Keys__PS_DICT_BLUE_VALUE: PS_Dict_Keys_ = 16;
pub const PS_Dict_Keys__PS_DICT_BLUE_FUZZ: PS_Dict_Keys_ = 17;
pub const PS_Dict_Keys__PS_DICT_NUM_OTHER_BLUES: PS_Dict_Keys_ = 18;
pub const PS_Dict_Keys__PS_DICT_OTHER_BLUE: PS_Dict_Keys_ = 19;
pub const PS_Dict_Keys__PS_DICT_NUM_FAMILY_BLUES: PS_Dict_Keys_ = 20;
pub const PS_Dict_Keys__PS_DICT_FAMILY_BLUE: PS_Dict_Keys_ = 21;
pub const PS_Dict_Keys__PS_DICT_NUM_FAMILY_OTHER_BLUES: PS_Dict_Keys_ = 22;
pub const PS_Dict_Keys__PS_DICT_FAMILY_OTHER_BLUE: PS_Dict_Keys_ = 23;
pub const PS_Dict_Keys__PS_DICT_BLUE_SCALE: PS_Dict_Keys_ = 24;
pub const PS_Dict_Keys__PS_DICT_BLUE_SHIFT: PS_Dict_Keys_ = 25;
pub const PS_Dict_Keys__PS_DICT_NUM_STEM_SNAP_H: PS_Dict_Keys_ = 26;
pub const PS_Dict_Keys__PS_DICT_STEM_SNAP_H: PS_Dict_Keys_ = 27;
pub const PS_Dict_Keys__PS_DICT_NUM_STEM_SNAP_V: PS_Dict_Keys_ = 28;
pub const PS_Dict_Keys__PS_DICT_STEM_SNAP_V: PS_Dict_Keys_ = 29;
pub const PS_Dict_Keys__PS_DICT_FORCE_BOLD: PS_Dict_Keys_ = 30;
pub const PS_Dict_Keys__PS_DICT_RND_STEM_UP: PS_Dict_Keys_ = 31;
pub const PS_Dict_Keys__PS_DICT_MIN_FEATURE: PS_Dict_Keys_ = 32;
pub const PS_Dict_Keys__PS_DICT_LEN_IV: PS_Dict_Keys_ = 33;
pub const PS_Dict_Keys__PS_DICT_PASSWORD: PS_Dict_Keys_ = 34;
pub const PS_Dict_Keys__PS_DICT_LANGUAGE_GROUP: PS_Dict_Keys_ = 35;
pub const PS_Dict_Keys__PS_DICT_VERSION: PS_Dict_Keys_ = 36;
pub const PS_Dict_Keys__PS_DICT_NOTICE: PS_Dict_Keys_ = 37;
pub const PS_Dict_Keys__PS_DICT_FULL_NAME: PS_Dict_Keys_ = 38;
pub const PS_Dict_Keys__PS_DICT_FAMILY_NAME: PS_Dict_Keys_ = 39;
pub const PS_Dict_Keys__PS_DICT_WEIGHT: PS_Dict_Keys_ = 40;
pub const PS_Dict_Keys__PS_DICT_IS_FIXED_PITCH: PS_Dict_Keys_ = 41;
pub const PS_Dict_Keys__PS_DICT_UNDERLINE_POSITION: PS_Dict_Keys_ = 42;
pub const PS_Dict_Keys__PS_DICT_UNDERLINE_THICKNESS: PS_Dict_Keys_ = 43;
pub const PS_Dict_Keys__PS_DICT_FS_TYPE: PS_Dict_Keys_ = 44;
pub const PS_Dict_Keys__PS_DICT_ITALIC_ANGLE: PS_Dict_Keys_ = 45;
pub const PS_Dict_Keys__PS_DICT_MAX: PS_Dict_Keys_ = 45;
pub type PS_Dict_Keys_ = ::std::os::raw::c_int;
pub use self::PS_Dict_Keys_ as PS_Dict_Keys;
extern "C" {

    /// @function:
    /// FT_Get_PS_Font_Value
    ///
    /// @description:
    /// Retrieve the value for the supplied key from a PostScript font.
    ///
    /// @input:
    /// face ::
    /// PostScript face handle.
    ///
    /// key ::
    /// An enumeration value representing the dictionary key to retrieve.
    ///
    /// idx ::
    /// For array values, this specifies the index to be returned.
    ///
    /// value ::
    /// A pointer to memory into which to write the value.
    ///
    /// valen_len ::
    /// The size, in bytes, of the memory supplied for the value.
    ///
    /// @output:
    /// value ::
    /// The value matching the above key, if it exists.
    ///
    /// @return:
    /// The amount of memory (in bytes) required to hold the requested
    /// value (if it exists, -1 otherwise).
    ///
    /// @note:
    /// The values returned are not pointers into the internal structures of
    /// the face, but are `fresh' copies, so that the memory containing them
    /// belongs to the calling application.  This also enforces the
    /// `read-only' nature of these values, i.e., this function cannot be
    /// used to manipulate the face.
    ///
    /// `value' is a void pointer because the values returned can be of
    /// various types.
    ///
    /// If either `value' is NULL or `value_len' is too small, just the
    /// required memory size for the requested entry is returned.
    ///
    /// The `idx' parameter is used, not only to retrieve elements of, for
    /// example, the FontMatrix or FontBBox, but also to retrieve name keys
    /// from the CharStrings dictionary, and the charstrings themselves.  It
    /// is ignored for atomic values.
    ///
    /// PS_DICT_BLUE_SCALE returns a value that is scaled up by 1000.  To
    /// get the value as in the font stream, you need to divide by
    /// 65536000.0 (to remove the FT_Fixed scale, and the x1000 scale).
    ///
    /// IMPORTANT: Only key/value pairs read by the FreeType interpreter can
    /// be retrieved.  So, for example, PostScript procedures such as NP,
    /// ND, and RD are not available.  Arbitrary keys are, obviously, not be
    /// available either.
    ///
    /// If the font's format is not PostScript-based, this function returns
    /// the `FT_Err_Invalid_Argument' error code.
    ///
    /// @since:
    /// 2.4.8
    ///
    pub fn FT_Get_PS_Font_Value(
        face: FT_Face,
        key: PS_Dict_Keys,
        idx: FT_UInt,
        value: *mut ::std::os::raw::c_void,
        value_len: FT_Long,
    ) -> FT_Long;
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_MM_Axis_ {
    pub name: *mut FT_String,
    pub minimum: FT_Long,
    pub maximum: FT_Long,
}
#[test]
fn bindgen_test_layout_FT_MM_Axis_() {
    assert_eq!(
        ::std::mem::size_of::<FT_MM_Axis_>(),
        16usize,
        concat!("Size of: ", stringify!(FT_MM_Axis_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_MM_Axis_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_MM_Axis_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_MM_Axis_)).name as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_MM_Axis_),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_MM_Axis_)).minimum as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_MM_Axis_),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_MM_Axis_)).maximum as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_MM_Axis_),
            "::",
            stringify!(maximum)
        )
    );
}
pub type FT_MM_Axis = FT_MM_Axis_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Multi_Master_ {
    pub num_axis: FT_UInt,
    pub num_designs: FT_UInt,
    pub axis: [FT_MM_Axis; 4usize],
}
#[test]
fn bindgen_test_layout_FT_Multi_Master_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Multi_Master_>(),
        72usize,
        concat!("Size of: ", stringify!(FT_Multi_Master_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Multi_Master_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Multi_Master_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Multi_Master_)).num_axis as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Multi_Master_),
            "::",
            stringify!(num_axis)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Multi_Master_)).num_designs as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Multi_Master_),
            "::",
            stringify!(num_designs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Multi_Master_)).axis as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Multi_Master_),
            "::",
            stringify!(axis)
        )
    );
}
pub type FT_Multi_Master = FT_Multi_Master_;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Var_Axis_ {
    pub name: *mut FT_String,
    pub minimum: FT_Fixed,
    pub def: FT_Fixed,
    pub maximum: FT_Fixed,
    pub tag: FT_ULong,
    pub strid: FT_UInt,
}
#[test]
fn bindgen_test_layout_FT_Var_Axis_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Var_Axis_>(),
        32usize,
        concat!("Size of: ", stringify!(FT_Var_Axis_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Var_Axis_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Var_Axis_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Var_Axis_)).name as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Var_Axis_),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Var_Axis_)).minimum as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Var_Axis_),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Var_Axis_)).def as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Var_Axis_),
            "::",
            stringify!(def)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Var_Axis_)).maximum as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Var_Axis_),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Var_Axis_)).tag as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Var_Axis_),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Var_Axis_)).strid as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Var_Axis_),
            "::",
            stringify!(strid)
        )
    );
}
pub type FT_Var_Axis = FT_Var_Axis_;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Var_Named_Style_ {
    pub coords: *mut FT_Fixed,
    pub strid: FT_UInt,
    pub psid: FT_UInt,
}
#[test]
fn bindgen_test_layout_FT_Var_Named_Style_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Var_Named_Style_>(),
        16usize,
        concat!("Size of: ", stringify!(FT_Var_Named_Style_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Var_Named_Style_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Var_Named_Style_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Var_Named_Style_)).coords as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Var_Named_Style_),
            "::",
            stringify!(coords)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Var_Named_Style_)).strid as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Var_Named_Style_),
            "::",
            stringify!(strid)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Var_Named_Style_)).psid as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Var_Named_Style_),
            "::",
            stringify!(psid)
        )
    );
}
pub type FT_Var_Named_Style = FT_Var_Named_Style_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_MM_Var_ {
    pub num_axis: FT_UInt,
    pub num_designs: FT_UInt,
    pub num_namedstyles: FT_UInt,
    pub axis: *mut FT_Var_Axis,
    pub namedstyle: *mut FT_Var_Named_Style,
}
#[test]
fn bindgen_test_layout_FT_MM_Var_() {
    assert_eq!(
        ::std::mem::size_of::<FT_MM_Var_>(),
        32usize,
        concat!("Size of: ", stringify!(FT_MM_Var_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_MM_Var_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_MM_Var_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_MM_Var_)).num_axis as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_MM_Var_),
            "::",
            stringify!(num_axis)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_MM_Var_)).num_designs as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_MM_Var_),
            "::",
            stringify!(num_designs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_MM_Var_)).num_namedstyles as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_MM_Var_),
            "::",
            stringify!(num_namedstyles)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_MM_Var_)).axis as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_MM_Var_),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_MM_Var_)).namedstyle as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_MM_Var_),
            "::",
            stringify!(namedstyle)
        )
    );
}
pub type FT_MM_Var = FT_MM_Var_;
extern "C" {



    pub fn FT_Get_Multi_Master(face: FT_Face, amaster: *mut FT_Multi_Master) -> FT_Error;
}
extern "C" {



    pub fn FT_Get_MM_Var(face: FT_Face, amaster: *mut *mut FT_MM_Var) -> FT_Error;
}
extern "C" {
    pub fn FT_Set_MM_Design_Coordinates(
        face: FT_Face,
        num_coords: FT_UInt,
        coords: *mut FT_Long,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Set_Var_Design_Coordinates(
        face: FT_Face,
        num_coords: FT_UInt,
        coords: *mut FT_Fixed,
    ) -> FT_Error;
}
extern "C" {



    pub fn FT_Get_Var_Design_Coordinates(
        face: FT_Face,
        num_coords: FT_UInt,
        coords: *mut FT_Fixed,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Set_MM_Blend_Coordinates(
        face: FT_Face,
        num_coords: FT_UInt,
        coords: *mut FT_Fixed,
    ) -> FT_Error;
}
extern "C" {



    pub fn FT_Get_MM_Blend_Coordinates(
        face: FT_Face,
        num_coords: FT_UInt,
        coords: *mut FT_Fixed,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Set_Var_Blend_Coordinates(
        face: FT_Face,
        num_coords: FT_UInt,
        coords: *mut FT_Fixed,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Get_Var_Blend_Coordinates(
        face: FT_Face,
        num_coords: FT_UInt,
        coords: *mut FT_Fixed,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Get_Var_Axis_Flags(
        master: *mut FT_MM_Var,
        axis_index: FT_UInt,
        flags: *mut FT_UInt,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Set_Named_Instance(face: FT_Face, instance_index: FT_UInt) -> FT_Error;
}
pub type FT_Module_Interface = FT_Pointer;

pub type FT_Module_Constructor = ::std::option::Option<
    unsafe extern "C" fn(module: FT_Module) -> FT_Error,
>;

pub type FT_Module_Destructor = ::std::option::Option<unsafe extern "C" fn(module: FT_Module)>;

pub type FT_Module_Requester = ::std::option::Option<
    unsafe extern "C" fn(module: FT_Module, name: *const ::std::os::raw::c_char)
        -> FT_Module_Interface,
>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Module_Class_ {
    pub module_flags: FT_ULong,
    pub module_size: FT_Long,
    pub module_name: *const FT_String,
    pub module_version: FT_Fixed,
    pub module_requires: FT_Fixed,
    pub module_interface: *const ::std::os::raw::c_void,
    pub module_init: FT_Module_Constructor,
    pub module_done: FT_Module_Destructor,
    pub get_interface: FT_Module_Requester,
}
#[test]
fn bindgen_test_layout_FT_Module_Class_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Module_Class_>(),
        56usize,
        concat!("Size of: ", stringify!(FT_Module_Class_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Module_Class_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Module_Class_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Module_Class_)).module_flags as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Module_Class_),
            "::",
            stringify!(module_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Module_Class_)).module_size as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Module_Class_),
            "::",
            stringify!(module_size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Module_Class_)).module_name as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Module_Class_),
            "::",
            stringify!(module_name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Module_Class_)).module_version as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Module_Class_),
            "::",
            stringify!(module_version)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Module_Class_)).module_requires as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Module_Class_),
            "::",
            stringify!(module_requires)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Module_Class_)).module_interface as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Module_Class_),
            "::",
            stringify!(module_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Module_Class_)).module_init as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Module_Class_),
            "::",
            stringify!(module_init)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Module_Class_)).module_done as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Module_Class_),
            "::",
            stringify!(module_done)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Module_Class_)).get_interface as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Module_Class_),
            "::",
            stringify!(get_interface)
        )
    );
}
pub type FT_Module_Class = FT_Module_Class_;
extern "C" {



    pub fn FT_Add_Module(library: FT_Library, clazz: *const FT_Module_Class) -> FT_Error;
}
extern "C" {



    pub fn FT_Get_Module(
        library: FT_Library,
        module_name: *const ::std::os::raw::c_char,
    ) -> FT_Module;
}
extern "C" {



    pub fn FT_Remove_Module(library: FT_Library, module: FT_Module) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Property_Set
    ///
    /// @description:
    /// Set a property for a given module.
    ///
    /// @input:
    /// library ::
    /// A handle to the library the module is part of.
    ///
    /// module_name ::
    /// The module name.
    ///
    /// property_name ::
    /// The property name.  Properties are described in the `Synopsis'
    /// subsection of the module's documentation.
    ///
    /// Note that only a few modules have properties.
    ///
    /// value ::
    /// A generic pointer to a variable or structure that gives the new
    /// value of the property.  The exact definition of `value' is
    /// dependent on the property; see the `Synopsis' subsection of the
    /// module's documentation.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// If `module_name' isn't a valid module name, or `property_name'
    /// doesn't specify a valid property, or if `value' doesn't represent a
    /// valid value for the given property, an error is returned.
    ///
    /// The following example sets property `bar' (a simple integer) in
    /// module `foo' to value~1.
    ///
    /// {
    /// FT_UInt  bar;
    ///
    ///
    /// bar = 1;
    /// FT_Property_Set( library, "foo", "bar", &bar );
    /// }
    ///
    /// Note that the FreeType Cache sub-system doesn't recognize module
    /// property changes.  To avoid glyph lookup confusion within the cache
    /// you should call @FTC_Manager_Reset to completely flush the cache if
    /// a module property gets changed after @FTC_Manager_New has been
    /// called.
    ///
    /// It is not possible to set properties of the FreeType Cache
    /// sub-system itself with FT_Property_Set; use @FTC_Property_Set
    /// instead.
    ///
    /// @since:
    /// 2.4.11
    ///
    pub fn FT_Property_Set(
        library: FT_Library,
        module_name: *const FT_String,
        property_name: *const FT_String,
        value: *const ::std::os::raw::c_void,
    ) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Property_Get
    ///
    /// @description:
    /// Get a module's property value.
    ///
    /// @input:
    /// library ::
    /// A handle to the library the module is part of.
    ///
    /// module_name ::
    /// The module name.
    ///
    /// property_name ::
    /// The property name.  Properties are described in the `Synopsis'
    /// subsection of the module's documentation.
    ///
    /// @inout:
    /// value ::
    /// A generic pointer to a variable or structure that gives the
    /// value of the property.  The exact definition of `value' is
    /// dependent on the property; see the `Synopsis' subsection of the
    /// module's documentation.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// If `module_name' isn't a valid module name, or `property_name'
    /// doesn't specify a valid property, or if `value' doesn't represent a
    /// valid value for the given property, an error is returned.
    ///
    /// The following example gets property `baz' (a range) in module `foo'.
    ///
    /// {
    /// typedef  range_
    /// {
    /// FT_Int32  min;
    /// FT_Int32  max;
    ///
    /// } range;
    ///
    /// range  baz;
    ///
    ///
    /// FT_Property_Get( library, "foo", "baz", &baz );
    /// }
    ///
    /// It is not possible to retrieve properties of the FreeType Cache
    /// sub-system with FT_Property_Get; use @FTC_Property_Get instead.
    ///
    /// @since:
    /// 2.4.11
    ///
    pub fn FT_Property_Get(
        library: FT_Library,
        module_name: *const FT_String,
        property_name: *const FT_String,
        value: *mut ::std::os::raw::c_void,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Set_Default_Properties(library: FT_Library);
}
extern "C" {
    pub fn FT_Reference_Library(library: FT_Library) -> FT_Error;
}
extern "C" {
    pub fn FT_New_Library(memory: FT_Memory, alibrary: *mut FT_Library) -> FT_Error;
}
extern "C" {
    pub fn FT_Done_Library(library: FT_Library) -> FT_Error;
}
pub type FT_DebugHook_Func = ::std::option::Option<
    unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void),
>;
extern "C" {



    pub fn FT_Set_Debug_Hook(
        library: FT_Library,
        hook_index: FT_UInt,
        debug_hook: FT_DebugHook_Func,
    );
}
extern "C" {
    pub fn FT_Add_Default_Modules(library: FT_Library);
}
pub const FT_TrueTypeEngineType__FT_TRUETYPE_ENGINE_TYPE_NONE: FT_TrueTypeEngineType_ = 0;
pub const FT_TrueTypeEngineType__FT_TRUETYPE_ENGINE_TYPE_UNPATENTED: FT_TrueTypeEngineType_ = 1;
pub const FT_TrueTypeEngineType__FT_TRUETYPE_ENGINE_TYPE_PATENTED: FT_TrueTypeEngineType_ = 2;
pub type FT_TrueTypeEngineType_ = ::std::os::raw::c_int;
pub use self::FT_TrueTypeEngineType_ as FT_TrueTypeEngineType;
extern "C" {

    /// @func:
    /// FT_Get_TrueType_Engine_Type
    ///
    /// @description:
    /// Return an @FT_TrueTypeEngineType value to indicate which level of
    /// the TrueType virtual machine a given library instance supports.
    ///
    /// @input:
    /// library ::
    /// A library instance.
    ///
    /// @return:
    /// A value indicating which level is supported.
    ///
    /// @since:
    /// 2.2
    ///
    pub fn FT_Get_TrueType_Engine_Type(library: FT_Library) -> FT_TrueTypeEngineType;
}
extern "C" {

    /// @function:
    /// FT_OpenType_Validate
    ///
    /// @description:
    /// Validate various OpenType tables to assure that all offsets and
    /// indices are valid.  The idea is that a higher-level library that
    /// actually does the text layout can access those tables without
    /// error checking (which can be quite time consuming).
    ///
    /// @input:
    /// face ::
    /// A handle to the input face.
    ///
    /// validation_flags ::
    /// A bit field that specifies the tables to be validated.  See
    /// @FT_VALIDATE_OTXXX for possible values.
    ///
    /// @output:
    /// BASE_table ::
    /// A pointer to the BASE table.
    ///
    /// GDEF_table ::
    /// A pointer to the GDEF table.
    ///
    /// GPOS_table ::
    /// A pointer to the GPOS table.
    ///
    /// GSUB_table ::
    /// A pointer to the GSUB table.
    ///
    /// JSTF_table ::
    /// A pointer to the JSTF table.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// This function only works with OpenType fonts, returning an error
    /// otherwise.
    ///
    /// After use, the application should deallocate the five tables with
    /// @FT_OpenType_Free.  A NULL value indicates that the table either
    /// doesn't exist in the font, or the application hasn't asked for
    /// validation.
    pub fn FT_OpenType_Validate(
        face: FT_Face,
        validation_flags: FT_UInt,
        BASE_table: *mut FT_Bytes,
        GDEF_table: *mut FT_Bytes,
        GPOS_table: *mut FT_Bytes,
        GSUB_table: *mut FT_Bytes,
        JSTF_table: *mut FT_Bytes,
    ) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_OpenType_Free
    ///
    /// @description:
    /// Free the buffer allocated by OpenType validator.
    ///
    /// @input:
    /// face ::
    /// A handle to the input face.
    ///
    /// table ::
    /// The pointer to the buffer that is allocated by
    /// @FT_OpenType_Validate.
    ///
    /// @note:
    /// This function must be used to free the buffer allocated by
    /// @FT_OpenType_Validate only.
    pub fn FT_OpenType_Free(face: FT_Face, table: FT_Bytes);
}
extern "C" {
    pub fn FT_Outline_Decompose(
        outline: *mut FT_Outline,
        func_interface: *const FT_Outline_Funcs,
        user: *mut ::std::os::raw::c_void,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Outline_New(
        library: FT_Library,
        numPoints: FT_UInt,
        numContours: FT_Int,
        anoutline: *mut FT_Outline,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Outline_New_Internal(
        memory: FT_Memory,
        numPoints: FT_UInt,
        numContours: FT_Int,
        anoutline: *mut FT_Outline,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Outline_Done(library: FT_Library, outline: *mut FT_Outline) -> FT_Error;
}
extern "C" {
    pub fn FT_Outline_Done_Internal(memory: FT_Memory, outline: *mut FT_Outline) -> FT_Error;
}
extern "C" {



    pub fn FT_Outline_Check(outline: *mut FT_Outline) -> FT_Error;
}
extern "C" {
    pub fn FT_Outline_Get_CBox(outline: *const FT_Outline, acbox: *mut FT_BBox);
}
extern "C" {



    pub fn FT_Outline_Translate(outline: *const FT_Outline, xOffset: FT_Pos, yOffset: FT_Pos);
}
extern "C" {



    pub fn FT_Outline_Copy(source: *const FT_Outline, target: *mut FT_Outline) -> FT_Error;
}
extern "C" {
    pub fn FT_Outline_Transform(outline: *const FT_Outline, matrix: *const FT_Matrix);
}
extern "C" {
    pub fn FT_Outline_Embolden(outline: *mut FT_Outline, strength: FT_Pos) -> FT_Error;
}
extern "C" {
    pub fn FT_Outline_EmboldenXY(
        outline: *mut FT_Outline,
        xstrength: FT_Pos,
        ystrength: FT_Pos,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Outline_Reverse(outline: *mut FT_Outline);
}
extern "C" {
    pub fn FT_Outline_Get_Bitmap(
        library: FT_Library,
        outline: *mut FT_Outline,
        abitmap: *const FT_Bitmap,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Outline_Render(
        library: FT_Library,
        outline: *mut FT_Outline,
        params: *mut FT_Raster_Params,
    ) -> FT_Error;
}
pub const FT_Orientation__FT_ORIENTATION_TRUETYPE: FT_Orientation_ = 0;
pub const FT_Orientation__FT_ORIENTATION_POSTSCRIPT: FT_Orientation_ = 1;
pub const FT_Orientation__FT_ORIENTATION_FILL_RIGHT: FT_Orientation_ = 0;
pub const FT_Orientation__FT_ORIENTATION_FILL_LEFT: FT_Orientation_ = 1;
pub const FT_Orientation__FT_ORIENTATION_NONE: FT_Orientation_ = 2;
pub type FT_Orientation_ = ::std::os::raw::c_int;
pub use self::FT_Orientation_ as FT_Orientation;
extern "C" {

    /// @function:
    /// FT_Outline_Get_Orientation
    ///
    /// @description:
    /// This function analyzes a glyph outline and tries to compute its
    /// fill orientation (see @FT_Orientation).  This is done by integrating
    /// the total area covered by the outline. The positive integral
    /// corresponds to the clockwise orientation and @FT_ORIENTATION_POSTSCRIPT
    /// is returned. The negative integral corresponds to the counter-clockwise
    /// orientation and @FT_ORIENTATION_TRUETYPE is returned.
    ///
    /// Note that this will return @FT_ORIENTATION_TRUETYPE for empty
    /// outlines.
    ///
    /// @input:
    /// outline ::
    /// A handle to the source outline.
    ///
    /// @return:
    /// The orientation.
    ///
    pub fn FT_Outline_Get_Orientation(outline: *mut FT_Outline) -> FT_Orientation;
}
extern "C" {

    /// @function:
    /// FT_Get_PFR_Metrics
    ///
    /// @description:
    /// Return the outline and metrics resolutions of a given PFR face.
    ///
    /// @input:
    /// face :: Handle to the input face.  It can be a non-PFR face.
    ///
    /// @output:
    /// aoutline_resolution ::
    /// Outline resolution.  This is equivalent to `face->units_per_EM'
    /// for non-PFR fonts.  Optional (parameter can be NULL).
    ///
    /// ametrics_resolution ::
    /// Metrics resolution.  This is equivalent to `outline_resolution'
    /// for non-PFR fonts.  Optional (parameter can be NULL).
    ///
    /// ametrics_x_scale ::
    /// A 16.16 fixed-point number used to scale distance expressed
    /// in metrics units to device sub-pixels.  This is equivalent to
    /// `face->size->x_scale', but for metrics only.  Optional (parameter
    /// can be NULL).
    ///
    /// ametrics_y_scale ::
    /// Same as `ametrics_x_scale' but for the vertical direction.
    /// optional (parameter can be NULL).
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// If the input face is not a PFR, this function will return an error.
    /// However, in all cases, it will return valid values.
    pub fn FT_Get_PFR_Metrics(
        face: FT_Face,
        aoutline_resolution: *mut FT_UInt,
        ametrics_resolution: *mut FT_UInt,
        ametrics_x_scale: *mut FT_Fixed,
        ametrics_y_scale: *mut FT_Fixed,
    ) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Get_PFR_Kerning
    ///
    /// @description:
    /// Return the kerning pair corresponding to two glyphs in a PFR face.
    /// The distance is expressed in metrics units, unlike the result of
    /// @FT_Get_Kerning.
    ///
    /// @input:
    /// face  :: A handle to the input face.
    ///
    /// left  :: Index of the left glyph.
    ///
    /// right :: Index of the right glyph.
    ///
    /// @output:
    /// avector :: A kerning vector.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// This function always return distances in original PFR metrics
    /// units.  This is unlike @FT_Get_Kerning with the @FT_KERNING_UNSCALED
    /// mode, which always returns distances converted to outline units.
    ///
    /// You can use the value of the `x_scale' and `y_scale' parameters
    /// returned by @FT_Get_PFR_Metrics to scale these to device sub-pixels.
    pub fn FT_Get_PFR_Kerning(
        face: FT_Face,
        left: FT_UInt,
        right: FT_UInt,
        avector: *mut FT_Vector,
    ) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Get_PFR_Advance
    ///
    /// @description:
    /// Return a given glyph advance, expressed in original metrics units,
    /// from a PFR font.
    ///
    /// @input:
    /// face   :: A handle to the input face.
    ///
    /// gindex :: The glyph index.
    ///
    /// @output:
    /// aadvance :: The glyph advance in metrics units.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// You can use the `x_scale' or `y_scale' results of @FT_Get_PFR_Metrics
    /// to convert the advance to device sub-pixels (i.e., 1/64th of pixels).
    pub fn FT_Get_PFR_Advance(face: FT_Face, gindex: FT_UInt, aadvance: *mut FT_Pos) -> FT_Error;
}

pub type FT_Glyph_InitFunc = ::std::option::Option<
    unsafe extern "C" fn(glyph: FT_Glyph, slot: FT_GlyphSlot) -> FT_Error,
>;
pub type FT_Glyph_DoneFunc = ::std::option::Option<unsafe extern "C" fn(glyph: FT_Glyph)>;
pub type FT_Glyph_TransformFunc = ::std::option::Option<
    unsafe extern "C" fn(glyph: FT_Glyph, matrix: *const FT_Matrix, delta: *const FT_Vector),
>;
pub type FT_Glyph_GetBBoxFunc = ::std::option::Option<
    unsafe extern "C" fn(glyph: FT_Glyph, abbox: *mut FT_BBox),
>;
pub type FT_Glyph_CopyFunc = ::std::option::Option<
    unsafe extern "C" fn(source: FT_Glyph, target: FT_Glyph) -> FT_Error,
>;
pub type FT_Glyph_PrepareFunc = ::std::option::Option<
    unsafe extern "C" fn(glyph: FT_Glyph, slot: FT_GlyphSlot) -> FT_Error,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Glyph_Class_ {
    pub glyph_size: FT_Long,
    pub glyph_format: FT_Glyph_Format,
    pub glyph_init: FT_Glyph_InitFunc,
    pub glyph_done: FT_Glyph_DoneFunc,
    pub glyph_copy: FT_Glyph_CopyFunc,
    pub glyph_transform: FT_Glyph_TransformFunc,
    pub glyph_bbox: FT_Glyph_GetBBoxFunc,
    pub glyph_prepare: FT_Glyph_PrepareFunc,
}
#[test]
fn bindgen_test_layout_FT_Glyph_Class_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Glyph_Class_>(),
        56usize,
        concat!("Size of: ", stringify!(FT_Glyph_Class_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Glyph_Class_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Glyph_Class_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Glyph_Class_)).glyph_size as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Glyph_Class_),
            "::",
            stringify!(glyph_size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Glyph_Class_)).glyph_format as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Glyph_Class_),
            "::",
            stringify!(glyph_format)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Glyph_Class_)).glyph_init as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Glyph_Class_),
            "::",
            stringify!(glyph_init)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Glyph_Class_)).glyph_done as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Glyph_Class_),
            "::",
            stringify!(glyph_done)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Glyph_Class_)).glyph_copy as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Glyph_Class_),
            "::",
            stringify!(glyph_copy)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Glyph_Class_)).glyph_transform as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Glyph_Class_),
            "::",
            stringify!(glyph_transform)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Glyph_Class_)).glyph_bbox as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Glyph_Class_),
            "::",
            stringify!(glyph_bbox)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Glyph_Class_)).glyph_prepare as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Glyph_Class_),
            "::",
            stringify!(glyph_prepare)
        )
    );
}
pub type FT_Renderer_RenderFunc = ::std::option::Option<
    unsafe extern "C" fn(
        renderer: FT_Renderer,
        slot: FT_GlyphSlot,
        mode: FT_UInt,
        origin: *const FT_Vector,
    ) -> FT_Error,
>;
pub type FT_Renderer_TransformFunc = ::std::option::Option<
    unsafe extern "C" fn(
        renderer: FT_Renderer,
        slot: FT_GlyphSlot,
        matrix: *const FT_Matrix,
        delta: *const FT_Vector,
    ) -> FT_Error,
>;
pub type FT_Renderer_GetCBoxFunc = ::std::option::Option<
    unsafe extern "C" fn(renderer: FT_Renderer, slot: FT_GlyphSlot, cbox: *mut FT_BBox),
>;
pub type FT_Renderer_SetModeFunc = ::std::option::Option<
    unsafe extern "C" fn(renderer: FT_Renderer, mode_tag: FT_ULong, mode_ptr: FT_Pointer)
        -> FT_Error,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Renderer_Class_ {
    pub root: FT_Module_Class,
    pub glyph_format: FT_Glyph_Format,
    pub render_glyph: FT_Renderer_RenderFunc,
    pub transform_glyph: FT_Renderer_TransformFunc,
    pub get_glyph_cbox: FT_Renderer_GetCBoxFunc,
    pub set_mode: FT_Renderer_SetModeFunc,
    pub raster_class: *mut FT_Raster_Funcs,
}
#[test]
fn bindgen_test_layout_FT_Renderer_Class_() {
    assert_eq!(
        ::std::mem::size_of::<FT_Renderer_Class_>(),
        104usize,
        concat!("Size of: ", stringify!(FT_Renderer_Class_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Renderer_Class_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Renderer_Class_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Renderer_Class_)).root as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Renderer_Class_),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Renderer_Class_)).glyph_format as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Renderer_Class_),
            "::",
            stringify!(glyph_format)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Renderer_Class_)).render_glyph as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Renderer_Class_),
            "::",
            stringify!(render_glyph)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Renderer_Class_)).transform_glyph as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Renderer_Class_),
            "::",
            stringify!(transform_glyph)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Renderer_Class_)).get_glyph_cbox as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Renderer_Class_),
            "::",
            stringify!(get_glyph_cbox)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Renderer_Class_)).set_mode as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Renderer_Class_),
            "::",
            stringify!(set_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_Renderer_Class_)).raster_class as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_Renderer_Class_),
            "::",
            stringify!(raster_class)
        )
    );
}
pub type FT_Renderer_Class = FT_Renderer_Class_;
extern "C" {
    pub fn FT_Get_Renderer(library: FT_Library, format: FT_Glyph_Format) -> FT_Renderer;
}
extern "C" {
    pub fn FT_Set_Renderer(
        library: FT_Library,
        renderer: FT_Renderer,
        num_params: FT_UInt,
        parameters: *mut FT_Parameter,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_New_Size(face: FT_Face, size: *mut FT_Size) -> FT_Error;
}
extern "C" {
    pub fn FT_Done_Size(size: FT_Size) -> FT_Error;
}
extern "C" {
    pub fn FT_Activate_Size(size: FT_Size) -> FT_Error;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_SfntName_ {
    pub platform_id: FT_UShort,
    pub encoding_id: FT_UShort,
    pub language_id: FT_UShort,
    pub name_id: FT_UShort,
    pub string: *mut FT_Byte,
    pub string_len: FT_UInt,
}
#[test]
fn bindgen_test_layout_FT_SfntName_() {
    assert_eq!(
        ::std::mem::size_of::<FT_SfntName_>(),
        24usize,
        concat!("Size of: ", stringify!(FT_SfntName_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_SfntName_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_SfntName_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_SfntName_)).platform_id as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_SfntName_),
            "::",
            stringify!(platform_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_SfntName_)).encoding_id as *const _ as usize },
        2usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_SfntName_),
            "::",
            stringify!(encoding_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_SfntName_)).language_id as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_SfntName_),
            "::",
            stringify!(language_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_SfntName_)).name_id as *const _ as usize },
        6usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_SfntName_),
            "::",
            stringify!(name_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_SfntName_)).string as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_SfntName_),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_SfntName_)).string_len as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_SfntName_),
            "::",
            stringify!(string_len)
        )
    );
}
pub type FT_SfntName = FT_SfntName_;
extern "C" {



    pub fn FT_Get_Sfnt_Name_Count(face: FT_Face) -> FT_UInt;
}
extern "C" {
    pub fn FT_Get_Sfnt_Name(face: FT_Face, idx: FT_UInt, aname: *mut FT_SfntName) -> FT_Error;
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_SfntLangTag_ {
    pub string: *mut FT_Byte,
    pub string_len: FT_UInt,
}
#[test]
fn bindgen_test_layout_FT_SfntLangTag_() {
    assert_eq!(
        ::std::mem::size_of::<FT_SfntLangTag_>(),
        16usize,
        concat!("Size of: ", stringify!(FT_SfntLangTag_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_SfntLangTag_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_SfntLangTag_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_SfntLangTag_)).string as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_SfntLangTag_),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_SfntLangTag_)).string_len as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_SfntLangTag_),
            "::",
            stringify!(string_len)
        )
    );
}
pub type FT_SfntLangTag = FT_SfntLangTag_;
extern "C" {
    pub fn FT_Get_Sfnt_LangTag(
        face: FT_Face,
        langID: FT_UInt,
        alangTag: *mut FT_SfntLangTag,
    ) -> FT_Error;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_StrokerRec_ {
    _unused: [u8; 0],
}
/// @type:
/// FT_Stroker
///
/// @description:
/// Opaque handle to a path stroker object.
pub type FT_Stroker = *mut FT_StrokerRec_;
pub const FT_Stroker_LineJoin__FT_STROKER_LINEJOIN_ROUND: FT_Stroker_LineJoin_ = 0;
pub const FT_Stroker_LineJoin__FT_STROKER_LINEJOIN_BEVEL: FT_Stroker_LineJoin_ = 1;
pub const FT_Stroker_LineJoin__FT_STROKER_LINEJOIN_MITER_VARIABLE: FT_Stroker_LineJoin_ = 2;
pub const FT_Stroker_LineJoin__FT_STROKER_LINEJOIN_MITER: FT_Stroker_LineJoin_ = 2;
pub const FT_Stroker_LineJoin__FT_STROKER_LINEJOIN_MITER_FIXED: FT_Stroker_LineJoin_ = 3;
pub type FT_Stroker_LineJoin_ = ::std::os::raw::c_int;
pub use self::FT_Stroker_LineJoin_ as FT_Stroker_LineJoin;
pub const FT_Stroker_LineCap__FT_STROKER_LINECAP_BUTT: FT_Stroker_LineCap_ = 0;
pub const FT_Stroker_LineCap__FT_STROKER_LINECAP_ROUND: FT_Stroker_LineCap_ = 1;
pub const FT_Stroker_LineCap__FT_STROKER_LINECAP_SQUARE: FT_Stroker_LineCap_ = 2;
pub type FT_Stroker_LineCap_ = ::std::os::raw::c_int;
pub use self::FT_Stroker_LineCap_ as FT_Stroker_LineCap;
pub const FT_StrokerBorder__FT_STROKER_BORDER_LEFT: FT_StrokerBorder_ = 0;
pub const FT_StrokerBorder__FT_STROKER_BORDER_RIGHT: FT_StrokerBorder_ = 1;
pub type FT_StrokerBorder_ = ::std::os::raw::c_int;
pub use self::FT_StrokerBorder_ as FT_StrokerBorder;
extern "C" {

    /// @function:
    /// FT_Outline_GetInsideBorder
    ///
    /// @description:
    /// Retrieve the @FT_StrokerBorder value corresponding to the
    /// `inside' borders of a given outline.
    ///
    /// @input:
    /// outline ::
    /// The source outline handle.
    ///
    /// @return:
    /// The border index.  @FT_STROKER_BORDER_RIGHT for empty or invalid
    /// outlines.
    pub fn FT_Outline_GetInsideBorder(outline: *mut FT_Outline) -> FT_StrokerBorder;
}
extern "C" {

    /// @function:
    /// FT_Outline_GetOutsideBorder
    ///
    /// @description:
    /// Retrieve the @FT_StrokerBorder value corresponding to the
    /// `outside' borders of a given outline.
    ///
    /// @input:
    /// outline ::
    /// The source outline handle.
    ///
    /// @return:
    /// The border index.  @FT_STROKER_BORDER_LEFT for empty or invalid
    /// outlines.
    pub fn FT_Outline_GetOutsideBorder(outline: *mut FT_Outline) -> FT_StrokerBorder;
}
extern "C" {

    /// @function:
    /// FT_Stroker_New
    ///
    /// @description:
    /// Create a new stroker object.
    ///
    /// @input:
    /// library ::
    /// FreeType library handle.
    ///
    /// @output:
    /// astroker ::
    /// A new stroker object handle.  NULL in case of error.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    pub fn FT_Stroker_New(library: FT_Library, astroker: *mut FT_Stroker) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Stroker_Set
    ///
    /// @description:
    /// Reset a stroker object's attributes.
    ///
    /// @input:
    /// stroker ::
    /// The target stroker handle.
    ///
    /// radius ::
    /// The border radius.
    ///
    /// line_cap ::
    /// The line cap style.
    ///
    /// line_join ::
    /// The line join style.
    ///
    /// miter_limit ::
    /// The miter limit for the FT_STROKER_LINEJOIN_MITER_FIXED and
    /// FT_STROKER_LINEJOIN_MITER_VARIABLE line join styles,
    /// expressed as 16.16 fixed-point value.
    ///
    /// @note:
    /// The radius is expressed in the same units as the outline
    /// coordinates.
    ///
    /// This function calls @FT_Stroker_Rewind automatically.
    pub fn FT_Stroker_Set(
        stroker: FT_Stroker,
        radius: FT_Fixed,
        line_cap: FT_Stroker_LineCap,
        line_join: FT_Stroker_LineJoin,
        miter_limit: FT_Fixed,
    );
}
extern "C" {

    /// @function:
    /// FT_Stroker_Rewind
    ///
    /// @description:
    /// Reset a stroker object without changing its attributes.
    /// You should call this function before beginning a new
    /// series of calls to @FT_Stroker_BeginSubPath or
    /// @FT_Stroker_EndSubPath.
    ///
    /// @input:
    /// stroker ::
    /// The target stroker handle.
    pub fn FT_Stroker_Rewind(stroker: FT_Stroker);
}
extern "C" {

    /// @function:
    /// FT_Stroker_ParseOutline
    ///
    /// @description:
    /// A convenience function used to parse a whole outline with
    /// the stroker.  The resulting outline(s) can be retrieved
    /// later by functions like @FT_Stroker_GetCounts and @FT_Stroker_Export.
    ///
    /// @input:
    /// stroker ::
    /// The target stroker handle.
    ///
    /// outline ::
    /// The source outline.
    ///
    /// opened ::
    /// A boolean.  If~1, the outline is treated as an open path instead
    /// of a closed one.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// If `opened' is~0 (the default), the outline is treated as a closed
    /// path, and the stroker generates two distinct `border' outlines.
    ///
    /// If `opened' is~1, the outline is processed as an open path, and the
    /// stroker generates a single `stroke' outline.
    ///
    /// This function calls @FT_Stroker_Rewind automatically.
    pub fn FT_Stroker_ParseOutline(
        stroker: FT_Stroker,
        outline: *mut FT_Outline,
        opened: FT_Bool,
    ) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Stroker_BeginSubPath
    ///
    /// @description:
    /// Start a new sub-path in the stroker.
    ///
    /// @input:
    /// stroker ::
    /// The target stroker handle.
    ///
    /// to ::
    /// A pointer to the start vector.
    ///
    /// open ::
    /// A boolean.  If~1, the sub-path is treated as an open one.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// This function is useful when you need to stroke a path that is
    /// not stored as an @FT_Outline object.
    pub fn FT_Stroker_BeginSubPath(
        stroker: FT_Stroker,
        to: *mut FT_Vector,
        open: FT_Bool,
    ) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Stroker_EndSubPath
    ///
    /// @description:
    /// Close the current sub-path in the stroker.
    ///
    /// @input:
    /// stroker ::
    /// The target stroker handle.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// You should call this function after @FT_Stroker_BeginSubPath.
    /// If the subpath was not `opened', this function `draws' a
    /// single line segment to the start position when needed.
    pub fn FT_Stroker_EndSubPath(stroker: FT_Stroker) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Stroker_LineTo
    ///
    /// @description:
    /// `Draw' a single line segment in the stroker's current sub-path,
    /// from the last position.
    ///
    /// @input:
    /// stroker ::
    /// The target stroker handle.
    ///
    /// to ::
    /// A pointer to the destination point.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// You should call this function between @FT_Stroker_BeginSubPath and
    /// @FT_Stroker_EndSubPath.
    pub fn FT_Stroker_LineTo(stroker: FT_Stroker, to: *mut FT_Vector) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Stroker_ConicTo
    ///
    /// @description:
    /// `Draw' a single quadratic Bézier in the stroker's current sub-path,
    /// from the last position.
    ///
    /// @input:
    /// stroker ::
    /// The target stroker handle.
    ///
    /// control ::
    /// A pointer to a Bézier control point.
    ///
    /// to ::
    /// A pointer to the destination point.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// You should call this function between @FT_Stroker_BeginSubPath and
    /// @FT_Stroker_EndSubPath.
    pub fn FT_Stroker_ConicTo(
        stroker: FT_Stroker,
        control: *mut FT_Vector,
        to: *mut FT_Vector,
    ) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Stroker_CubicTo
    ///
    /// @description:
    /// `Draw' a single cubic Bézier in the stroker's current sub-path,
    /// from the last position.
    ///
    /// @input:
    /// stroker ::
    /// The target stroker handle.
    ///
    /// control1 ::
    /// A pointer to the first Bézier control point.
    ///
    /// control2 ::
    /// A pointer to second Bézier control point.
    ///
    /// to ::
    /// A pointer to the destination point.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// You should call this function between @FT_Stroker_BeginSubPath and
    /// @FT_Stroker_EndSubPath.
    pub fn FT_Stroker_CubicTo(
        stroker: FT_Stroker,
        control1: *mut FT_Vector,
        control2: *mut FT_Vector,
        to: *mut FT_Vector,
    ) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Stroker_GetBorderCounts
    ///
    /// @description:
    /// Call this function once you have finished parsing your paths
    /// with the stroker.  It returns the number of points and
    /// contours necessary to export one of the `border' or `stroke'
    /// outlines generated by the stroker.
    ///
    /// @input:
    /// stroker ::
    /// The target stroker handle.
    ///
    /// border ::
    /// The border index.
    ///
    /// @output:
    /// anum_points ::
    /// The number of points.
    ///
    /// anum_contours ::
    /// The number of contours.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// When an outline, or a sub-path, is `closed', the stroker generates
    /// two independent `border' outlines, named `left' and `right'.
    ///
    /// When the outline, or a sub-path, is `opened', the stroker merges
    /// the `border' outlines with caps.  The `left' border receives all
    /// points, while the `right' border becomes empty.
    ///
    /// Use the function @FT_Stroker_GetCounts instead if you want to
    /// retrieve the counts associated to both borders.
    pub fn FT_Stroker_GetBorderCounts(
        stroker: FT_Stroker,
        border: FT_StrokerBorder,
        anum_points: *mut FT_UInt,
        anum_contours: *mut FT_UInt,
    ) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Stroker_ExportBorder
    ///
    /// @description:
    /// Call this function after @FT_Stroker_GetBorderCounts to
    /// export the corresponding border to your own @FT_Outline
    /// structure.
    ///
    /// Note that this function appends the border points and
    /// contours to your outline, but does not try to resize its
    /// arrays.
    ///
    /// @input:
    /// stroker ::
    /// The target stroker handle.
    ///
    /// border ::
    /// The border index.
    ///
    /// outline ::
    /// The target outline handle.
    ///
    /// @note:
    /// Always call this function after @FT_Stroker_GetBorderCounts to
    /// get sure that there is enough room in your @FT_Outline object to
    /// receive all new data.
    ///
    /// When an outline, or a sub-path, is `closed', the stroker generates
    /// two independent `border' outlines, named `left' and `right'.
    ///
    /// When the outline, or a sub-path, is `opened', the stroker merges
    /// the `border' outlines with caps.  The `left' border receives all
    /// points, while the `right' border becomes empty.
    ///
    /// Use the function @FT_Stroker_Export instead if you want to
    /// retrieve all borders at once.
    pub fn FT_Stroker_ExportBorder(
        stroker: FT_Stroker,
        border: FT_StrokerBorder,
        outline: *mut FT_Outline,
    );
}
extern "C" {

    /// @function:
    /// FT_Stroker_GetCounts
    ///
    /// @description:
    /// Call this function once you have finished parsing your paths
    /// with the stroker.  It returns the number of points and
    /// contours necessary to export all points/borders from the stroked
    /// outline/path.
    ///
    /// @input:
    /// stroker ::
    /// The target stroker handle.
    ///
    /// @output:
    /// anum_points ::
    /// The number of points.
    ///
    /// anum_contours ::
    /// The number of contours.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    pub fn FT_Stroker_GetCounts(
        stroker: FT_Stroker,
        anum_points: *mut FT_UInt,
        anum_contours: *mut FT_UInt,
    ) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Stroker_Export
    ///
    /// @description:
    /// Call this function after @FT_Stroker_GetBorderCounts to
    /// export all borders to your own @FT_Outline structure.
    ///
    /// Note that this function appends the border points and
    /// contours to your outline, but does not try to resize its
    /// arrays.
    ///
    /// @input:
    /// stroker ::
    /// The target stroker handle.
    ///
    /// outline ::
    /// The target outline handle.
    pub fn FT_Stroker_Export(stroker: FT_Stroker, outline: *mut FT_Outline);
}
extern "C" {

    /// @function:
    /// FT_Stroker_Done
    ///
    /// @description:
    /// Destroy a stroker object.
    ///
    /// @input:
    /// stroker ::
    /// A stroker handle.  Can be NULL.
    pub fn FT_Stroker_Done(stroker: FT_Stroker);
}
extern "C" {

    /// @function:
    /// FT_Glyph_Stroke
    ///
    /// @description:
    /// Stroke a given outline glyph object with a given stroker.
    ///
    /// @inout:
    /// pglyph ::
    /// Source glyph handle on input, new glyph handle on output.
    ///
    /// @input:
    /// stroker ::
    /// A stroker handle.
    ///
    /// destroy ::
    /// A Boolean.  If~1, the source glyph object is destroyed
    /// on success.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// The source glyph is untouched in case of error.
    ///
    /// Adding stroke may yield a significantly wider and taller glyph
    /// depending on how large of a radius was used to stroke the glyph.  You
    /// may need to manually adjust horizontal and vertical advance amounts
    /// to account for this added size.
    pub fn FT_Glyph_Stroke(
        pglyph: *mut FT_Glyph,
        stroker: FT_Stroker,
        destroy: FT_Bool,
    ) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Glyph_StrokeBorder
    ///
    /// @description:
    /// Stroke a given outline glyph object with a given stroker, but
    /// only return either its inside or outside border.
    ///
    /// @inout:
    /// pglyph ::
    /// Source glyph handle on input, new glyph handle on output.
    ///
    /// @input:
    /// stroker ::
    /// A stroker handle.
    ///
    /// inside ::
    /// A Boolean.  If~1, return the inside border, otherwise
    /// the outside border.
    ///
    /// destroy ::
    /// A Boolean.  If~1, the source glyph object is destroyed
    /// on success.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// The source glyph is untouched in case of error.
    ///
    /// Adding stroke may yield a significantly wider and taller glyph
    /// depending on how large of a radius was used to stroke the glyph.  You
    /// may need to manually adjust horizontal and vertical advance amounts
    /// to account for this added size.
    pub fn FT_Glyph_StrokeBorder(
        pglyph: *mut FT_Glyph,
        stroker: FT_Stroker,
        inside: FT_Bool,
        destroy: FT_Bool,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_GlyphSlot_Embolden(slot: FT_GlyphSlot);
}
extern "C" {
    pub fn FT_GlyphSlot_Oblique(slot: FT_GlyphSlot);
}
/// @type:
/// FT_Angle
///
/// @description:
/// This type is used to model angle values in FreeType.  Note that the
/// angle is a 16.16 fixed-point value expressed in degrees.
///
pub type FT_Angle = FT_Fixed;
extern "C" {

    /// @function:
    /// FT_Sin
    ///
    /// @description:
    /// Return the sinus of a given angle in fixed-point format.
    ///
    /// @input:
    /// angle ::
    /// The input angle.
    ///
    /// @return:
    /// The sinus value.
    ///
    /// @note:
    /// If you need both the sinus and cosinus for a given angle, use the
    /// function @FT_Vector_Unit.
    ///
    pub fn FT_Sin(angle: FT_Angle) -> FT_Fixed;
}
extern "C" {

    /// @function:
    /// FT_Cos
    ///
    /// @description:
    /// Return the cosinus of a given angle in fixed-point format.
    ///
    /// @input:
    /// angle ::
    /// The input angle.
    ///
    /// @return:
    /// The cosinus value.
    ///
    /// @note:
    /// If you need both the sinus and cosinus for a given angle, use the
    /// function @FT_Vector_Unit.
    ///
    pub fn FT_Cos(angle: FT_Angle) -> FT_Fixed;
}
extern "C" {

    /// @function:
    /// FT_Tan
    ///
    /// @description:
    /// Return the tangent of a given angle in fixed-point format.
    ///
    /// @input:
    /// angle ::
    /// The input angle.
    ///
    /// @return:
    /// The tangent value.
    ///
    pub fn FT_Tan(angle: FT_Angle) -> FT_Fixed;
}
extern "C" {

    /// @function:
    /// FT_Atan2
    ///
    /// @description:
    /// Return the arc-tangent corresponding to a given vector (x,y) in
    /// the 2d plane.
    ///
    /// @input:
    /// x ::
    /// The horizontal vector coordinate.
    ///
    /// y ::
    /// The vertical vector coordinate.
    ///
    /// @return:
    /// The arc-tangent value (i.e. angle).
    ///
    pub fn FT_Atan2(x: FT_Fixed, y: FT_Fixed) -> FT_Angle;
}
extern "C" {

    /// @function:
    /// FT_Angle_Diff
    ///
    /// @description:
    /// Return the difference between two angles.  The result is always
    /// constrained to the ]-PI..PI] interval.
    ///
    /// @input:
    /// angle1 ::
    /// First angle.
    ///
    /// angle2 ::
    /// Second angle.
    ///
    /// @return:
    /// Constrained value of `value2-value1'.
    ///
    pub fn FT_Angle_Diff(angle1: FT_Angle, angle2: FT_Angle) -> FT_Angle;
}
extern "C" {

    /// @function:
    /// FT_Vector_Unit
    ///
    /// @description:
    /// Return the unit vector corresponding to a given angle.  After the
    /// call, the value of `vec.x' will be `cos(angle)', and the value of
    /// `vec.y' will be `sin(angle)'.
    ///
    /// This function is useful to retrieve both the sinus and cosinus of a
    /// given angle quickly.
    ///
    /// @output:
    /// vec ::
    /// The address of target vector.
    ///
    /// @input:
    /// angle ::
    /// The input angle.
    ///
    pub fn FT_Vector_Unit(vec: *mut FT_Vector, angle: FT_Angle);
}
extern "C" {

    /// @function:
    /// FT_Vector_Rotate
    ///
    /// @description:
    /// Rotate a vector by a given angle.
    ///
    /// @inout:
    /// vec ::
    /// The address of target vector.
    ///
    /// @input:
    /// angle ::
    /// The input angle.
    ///
    pub fn FT_Vector_Rotate(vec: *mut FT_Vector, angle: FT_Angle);
}
extern "C" {

    /// @function:
    /// FT_Vector_Length
    ///
    /// @description:
    /// Return the length of a given vector.
    ///
    /// @input:
    /// vec ::
    /// The address of target vector.
    ///
    /// @return:
    /// The vector length, expressed in the same units that the original
    /// vector coordinates.
    ///
    pub fn FT_Vector_Length(vec: *mut FT_Vector) -> FT_Fixed;
}
extern "C" {

    /// @function:
    /// FT_Vector_Polarize
    ///
    /// @description:
    /// Compute both the length and angle of a given vector.
    ///
    /// @input:
    /// vec ::
    /// The address of source vector.
    ///
    /// @output:
    /// length ::
    /// The vector length.
    ///
    /// angle ::
    /// The vector angle.
    ///
    pub fn FT_Vector_Polarize(vec: *mut FT_Vector, length: *mut FT_Fixed, angle: *mut FT_Angle);
}
extern "C" {

    /// @function:
    /// FT_Vector_From_Polar
    ///
    /// @description:
    /// Compute vector coordinates from a length and angle.
    ///
    /// @output:
    /// vec ::
    /// The address of source vector.
    ///
    /// @input:
    /// length ::
    /// The vector length.
    ///
    /// angle ::
    /// The vector angle.
    ///
    pub fn FT_Vector_From_Polar(vec: *mut FT_Vector, length: FT_Fixed, angle: FT_Angle);
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct FT_WinFNT_HeaderRec_ {
    pub version: FT_UShort,
    pub file_size: FT_ULong,
    pub copyright: [FT_Byte; 60usize],
    pub file_type: FT_UShort,
    pub nominal_point_size: FT_UShort,
    pub vertical_resolution: FT_UShort,
    pub horizontal_resolution: FT_UShort,
    pub ascent: FT_UShort,
    pub internal_leading: FT_UShort,
    pub external_leading: FT_UShort,
    pub italic: FT_Byte,
    pub underline: FT_Byte,
    pub strike_out: FT_Byte,
    pub weight: FT_UShort,
    pub charset: FT_Byte,
    pub pixel_width: FT_UShort,
    pub pixel_height: FT_UShort,
    pub pitch_and_family: FT_Byte,
    pub avg_width: FT_UShort,
    pub max_width: FT_UShort,
    pub first_char: FT_Byte,
    pub last_char: FT_Byte,
    pub default_char: FT_Byte,
    pub break_char: FT_Byte,
    pub bytes_per_row: FT_UShort,
    pub device_offset: FT_ULong,
    pub face_name_offset: FT_ULong,
    pub bits_pointer: FT_ULong,
    pub bits_offset: FT_ULong,
    pub reserved: FT_Byte,
    pub flags: FT_ULong,
    pub A_space: FT_UShort,
    pub B_space: FT_UShort,
    pub C_space: FT_UShort,
    pub color_table_offset: FT_UShort,
    pub reserved1: [FT_ULong; 4usize],
}
#[test]
fn bindgen_test_layout_FT_WinFNT_HeaderRec_() {
    assert_eq!(
        ::std::mem::size_of::<FT_WinFNT_HeaderRec_>(),
        156usize,
        concat!("Size of: ", stringify!(FT_WinFNT_HeaderRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_WinFNT_HeaderRec_>(),
        4usize,
        concat!("Alignment of ", stringify!(FT_WinFNT_HeaderRec_))
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).version as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).file_size as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(file_size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).copyright as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(copyright)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).file_type as *const _ as usize },
        68usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(file_type)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).nominal_point_size as *const _ as usize },
        70usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(nominal_point_size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).vertical_resolution as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(vertical_resolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const FT_WinFNT_HeaderRec_)).horizontal_resolution as *const _ as usize
        },
        74usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(horizontal_resolution)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).ascent as *const _ as usize },
        76usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).internal_leading as *const _ as usize },
        78usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(internal_leading)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).external_leading as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(external_leading)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).italic as *const _ as usize },
        82usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(italic)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).underline as *const _ as usize },
        83usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(underline)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).strike_out as *const _ as usize },
        84usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(strike_out)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).weight as *const _ as usize },
        86usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(weight)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).charset as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(charset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).pixel_width as *const _ as usize },
        90usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(pixel_width)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).pixel_height as *const _ as usize },
        92usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(pixel_height)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).pitch_and_family as *const _ as usize },
        94usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(pitch_and_family)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).avg_width as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(avg_width)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).max_width as *const _ as usize },
        98usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).first_char as *const _ as usize },
        100usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(first_char)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).last_char as *const _ as usize },
        101usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(last_char)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).default_char as *const _ as usize },
        102usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(default_char)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).break_char as *const _ as usize },
        103usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(break_char)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).bytes_per_row as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(bytes_per_row)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).device_offset as *const _ as usize },
        108usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(device_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).face_name_offset as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(face_name_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).bits_pointer as *const _ as usize },
        116usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(bits_pointer)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).bits_offset as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(bits_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).reserved as *const _ as usize },
        124usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).flags as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).A_space as *const _ as usize },
        132usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(A_space)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).B_space as *const _ as usize },
        134usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(B_space)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).C_space as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(C_space)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).color_table_offset as *const _ as usize },
        138usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(color_table_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const FT_WinFNT_HeaderRec_)).reserved1 as *const _ as usize },
        140usize,
        concat!(
            "Alignment of field: ",
            stringify!(FT_WinFNT_HeaderRec_),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type FT_WinFNT_HeaderRec = FT_WinFNT_HeaderRec_;
pub type FT_WinFNT_Header = *mut FT_WinFNT_HeaderRec_;
extern "C" {

    /// @function:
    /// FT_Get_WinFNT_Header
    ///
    /// @description:
    /// Retrieve a Windows FNT font info header.
    ///
    /// @input:
    /// face    :: A handle to the input face.
    ///
    /// @output:
    /// aheader :: The WinFNT header.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// This function only works with Windows FNT faces, returning an error
    /// otherwise.
    pub fn FT_Get_WinFNT_Header(face: FT_Face, aheader: *mut FT_WinFNT_HeaderRec) -> FT_Error;
}
pub const FT_Sfnt_Tag__FT_SFNT_HEAD: FT_Sfnt_Tag_ = 0;
pub const FT_Sfnt_Tag__FT_SFNT_MAXP: FT_Sfnt_Tag_ = 1;
pub const FT_Sfnt_Tag__FT_SFNT_OS2: FT_Sfnt_Tag_ = 2;
pub const FT_Sfnt_Tag__FT_SFNT_HHEA: FT_Sfnt_Tag_ = 3;
pub const FT_Sfnt_Tag__FT_SFNT_VHEA: FT_Sfnt_Tag_ = 4;
pub const FT_Sfnt_Tag__FT_SFNT_POST: FT_Sfnt_Tag_ = 5;
pub const FT_Sfnt_Tag__FT_SFNT_PCLT: FT_Sfnt_Tag_ = 6;
pub const FT_Sfnt_Tag__FT_SFNT_MAX: FT_Sfnt_Tag_ = 7;
pub type FT_Sfnt_Tag_ = ::std::os::raw::c_int;
pub use self::FT_Sfnt_Tag_ as FT_Sfnt_Tag;
extern "C" {
    pub fn FT_Get_Sfnt_Table(face: FT_Face, tag: FT_Sfnt_Tag) -> *mut ::std::os::raw::c_void;
}
extern "C" {

    /// @function:
    /// FT_Load_Sfnt_Table
    ///
    /// @description:
    /// Load any SFNT font table into client memory.
    ///
    /// @input:
    /// face ::
    /// A handle to the source face.
    ///
    /// tag ::
    /// The four-byte tag of the table to load.  Use value~0 if you want
    /// to access the whole font file.  Otherwise, you can use one of the
    /// definitions found in the @FT_TRUETYPE_TAGS_H file, or forge a new
    /// one with @FT_MAKE_TAG.
    ///
    /// offset ::
    /// The starting offset in the table (or file if tag~==~0).
    ///
    /// @output:
    /// buffer ::
    /// The target buffer address.  The client must ensure that the memory
    /// array is big enough to hold the data.
    ///
    /// @inout:
    /// length ::
    /// If the `length' parameter is NULL, try to load the whole table.
    /// Return an error code if it fails.
    ///
    /// Else, if `*length' is~0, exit immediately while returning the
    /// table's (or file) full size in it.
    ///
    /// Else the number of bytes to read from the table or file, from the
    /// starting offset.
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// If you need to determine the table's length you should first call this
    /// function with `*length' set to~0, as in the following example:
    ///
    /// {
    /// FT_ULong  length = 0;
    ///
    ///
    /// error = FT_Load_Sfnt_Table( face, tag, 0, NULL, &length );
    /// if ( error ) { ... table does not exist ... }
    ///
    /// buffer = malloc( length );
    /// if ( buffer == NULL ) { ... not enough memory ... }
    ///
    /// error = FT_Load_Sfnt_Table( face, tag, 0, buffer, &length );
    /// if ( error ) { ... could not load table ... }
    /// }
    ///
    /// Note that structures like @TT_Header or @TT_OS2 can't be used with
    /// this function; they are limited to @FT_Get_Sfnt_Table.  Reason is that
    /// those structures depend on the processor architecture, with varying
    /// size (e.g. 32bit vs. 64bit) or order (big endian vs. little endian).
    ///
    pub fn FT_Load_Sfnt_Table(
        face: FT_Face,
        tag: FT_ULong,
        offset: FT_Long,
        buffer: *mut FT_Byte,
        length: *mut FT_ULong,
    ) -> FT_Error;
}
extern "C" {

    /// @function:
    /// FT_Sfnt_Table_Info
    ///
    /// @description:
    /// Return information on an SFNT table.
    ///
    /// @input:
    /// face ::
    /// A handle to the source face.
    ///
    /// table_index ::
    /// The index of an SFNT table.  The function returns
    /// FT_Err_Table_Missing for an invalid value.
    ///
    /// @inout:
    /// tag ::
    /// The name tag of the SFNT table.  If the value is NULL, `table_index'
    /// is ignored, and `length' returns the number of SFNT tables in the
    /// font.
    ///
    /// @output:
    /// length ::
    /// The length of the SFNT table (or the number of SFNT tables, depending
    /// on `tag').
    ///
    /// @return:
    /// FreeType error code.  0~means success.
    ///
    /// @note:
    /// While parsing fonts, FreeType handles SFNT tables with length zero as
    /// missing.
    ///
    pub fn FT_Sfnt_Table_Info(
        face: FT_Face,
        table_index: FT_UInt,
        tag: *mut FT_ULong,
        length: *mut FT_ULong,
    ) -> FT_Error;
}
extern "C" {
    pub fn FT_Get_CMap_Language_ID(charmap: FT_CharMap) -> FT_ULong;
}
extern "C" {



    pub fn FT_Get_CMap_Format(charmap: FT_CharMap) -> FT_Long;
}
